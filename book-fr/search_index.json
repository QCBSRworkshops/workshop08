[["index.html", "Atelier 8 : Modèles additifs généralisés en R Série d’ateliers R du CSBQ Préface 0.1 Code de conduit 0.2 Contributeurs et contributrices 0.3 Contribuez à la série!", " Atelier 8 : Modèles additifs généralisés en R Série d’ateliers R du CSBQ Développé et maintenu par les contributeurs et contributrices de la Série d’ateliers R du CSBQ1. 2021-07-28 20:38:12 Préface La Série d’ateliers R du CSBQ est une série de 10 ateliers qui guide les participants à travers les étapes nécessaires à l’utilisation de R pour un large éventail d’analyses statistiques pertinentes pour la recherche en biologie et en écologie. Ces ateliers en accès libre ont été créés par des membres du CSBQ, à la fois pour les membres du CSBQ et pour la communauté au sens large. Le contenu de cet atelier a été revu par plusieurs membres du CSBQ. Si vous souhaitez suggérer des modifications, veuillez contacter les coordinateurs de la série actuelle, dont la liste figure sur la page principale de Github 0.1 Code de conduit La Série d’ateliers R du CSBQ et le Symposium R du CSBQ sont des lieux dédiés à fournir un environnement accueillant et favorable à toutes les personnes, indépendamment de leurs origines ou de leur identité. Les participants, les présentateurs et les organisateurs de la série d’ateliers et d’autres activités connexes acceptent le présent code de conduite lorsqu’ils assistent à des activités liées aux ateliers. Nous ne tolérons pas les comportements irrespectueux ou qui excluent, intimident ou gênent les autres. Nous ne tolérons pas la discrimination ou le harcèlement fondés sur des caractéristiques telles que, mais sans s’y limiter, l’identité et l’expression du genre, l’orientation sexuelle, le handicap, l’apparence physique, la taille du corps, la citoyenneté, la nationalité, les origines ethniques ou sociales, la grossesse, le statut familial, les informations génétiques, la religion ou les convictions (ou l’absence de celles-ci), l’appartenance à une minorité nationale, la propriété, l’âge, l’éducation, le statut socio-économique, les choix techniques et le niveau d’expérience. Il s’applique à tous les espaces gérés par l’atelier ou affiliés à celui-ci, y compris, mais sans s’y limiter, les ateliers, les listes de diffusion et les forums en ligne tels que GitHub, Slack et Twitter. 0.1.1 Comportement attendu Tous les participants sont tenus de faire preuve de respect et de courtoisie envers les autres. Toutes les interactions doivent être professionnelles, quelle que soit la plateforme utilisée : en ligne ou en personne. Afin de favoriser un environnement d’apprentissage positif et professionnel, nous encourageons les types de comportements suivants dans tous les événements et plates-formes des ateliers : Utiliser un langage accueillant et inclusif ; Respecter les différents points de vue et expériences ; Accepter avec grâce les critiques constructives ; Se concentrer sur ce qui est le mieux pour la communauté ; Faire preuve de courtoisie et de respect envers les autres membres de la communauté. 0.1.2 Comportements inacceptables Voici quelques exemples de comportements inacceptables de la part des participants à tout événement ou plateforme d’atelier : les commentaires écrits ou verbaux qui ont pour effet d’exclure des personnes sur la base de leur appartenance à un groupe spécifique ; faire craindre à quelqu’un pour sa sécurité, par exemple en le harcelant ou en l’intimidant ; des menaces ou des propos violents dirigés contre une autre personne ; l’affichage d’images sexuelles ou violentes ; l’attention sexuelle non désirée ; les contacts physiques non consensuels ou non désirés ; des insultes ou des rabais ; les blagues sexistes, racistes, homophobes, transphobes, incapables ou d’exclusion ; l’incitation à la violence, au suicide ou à l’automutilation ; la poursuite de l’interaction (y compris la photographie ou l’enregistrement) avec une personne après qu’on - lui a demandé d’arrêter ; la publication d’une communication privée sans consentement. 0.2 Contributeurs et contributrices Développé à l’origine par : A contribué à modifier la présentation : Contribution avec des changements à la documentation écrite : Contribution en signalant des problèmes et en suggérant des modifications : 0.3 Contribuez à la série! En construction. La Série d’ateliers R du CSBQ fait partie du Centre de la science de la biodiversité du Québec, et est maintenue par les coordonnateurs et les coordonnatrices de la série, et les membres étudiants diplômés, postdoctoraux et professionnels de la recherche. Les contributeurs et contributrices de cet atelier sont accessiblesici↩︎ "],["résumé-et-objectifs-dapprentissage.html", "Chapitre 1 Résumé et Objectifs d’apprentissage 1.1 Résumé 1.2 Objectifs d’apprentissage", " Chapitre 1 Résumé et Objectifs d’apprentissage 1.1 Résumé L’objectif de l’atelier d’aujourd’hui sera d’examiner ce que nous entendons par un modèle non-linéaire et comment les GAMs (modèles additifs généralisés) nous permettent de modéliser les relations non-linéaires. Nous examinerons également comment tracer et interpréter ces relations non-linéaires, comment ajouter des interactions, comment prendre en compte la non-indépendance des données (e.g. erreurs autocorrélées) et comment inclure des effets aléatoires en se basant sur les ateliers précédents. Enfin, nous allons brièvement aborder la mécanique derrière le fonctionnement des GAMs. 1.2 Objectifs d’apprentissage Utiliser la librairie mgcv pour modéliser les relations non linéaires Évaluer la sortie d’un GAM afin de mieux comprendre nos données Utiliser des tests pour déterminer si nos relations correspondent à des modèles non linéaires ou linéaires Ajouter des interactions non linéaires entre les variables explicatives Comprendre l’idée d’une fonction de base (basis function) et la raison pour laquelle ça rend les GAMs si puissants ! Comment modéliser la dépendance dans les données (autocorrélation, structure hiérarchique) en utilisant les GAMMs "],["préparez-vous-pour-cet-atelier.html", "Chapitre 2 Préparez-vous pour cet atelier", " Chapitre 2 Préparez-vous pour cet atelier Pour vous preparer pour cet atelier, vous devez suivre les étapes suivantes: Téléchargez le script R et les données pour cet atelier: Script R Données Télechargez les paquets R pour cet atelier (vous pouvez suivre le script pour plus d’instructions): ggplot2 (for plotting) mgcv (for GAM fitting) itsadug (for visualization of GAMs) install.packages(&quot;ggplot2&quot;) install.packages(&quot;mgcv&quot;) install.packages(&quot;itsadug&quot;) library(ggplot2) library(itsadug) library(itsadug) source(file.choose()) # use coldiss.R which you have downloaded to your own directory "],["le-modèle-linéaireet-où-il-échoue.html", "Chapitre 3 Le modèle linéaire…et où il échoue", " Chapitre 3 Le modèle linéaire…et où il échoue Qu’est-ce qu’un modèle linéaire ? La régression linéaire est ce que la plupart des gens apprennent avant tout en statistiques et est parmi les méthodes les plus performantes. Elle nous permet de modéliser une variable réponse en fonction de facteurs prédictifs et d’une erreur résiduelle. Tel que vu dans l’atelier sur les modèles linéaires, la régression fait cependant quatre suppositions importantes : l’erreur est distribuée normalement la variance des erreurs est constante chaque erreur est indépendante des autres (homoscédasticité) la réponse est linéaire: y = β0 + β1x Il n’y a qu’une façon pour qu’un modèle linéaire soit correctement appliqué : et pourtant tant de façons pour qu’il ne le soit pas : Alors, comment résoudre ce problème ? Nous devons premièrement savoir ce que le modèle de régression cherche à faire : * ajuster une ligne qui passe au milieu des données, * faire cela sans sur-ajuster les données, c&#39;est-à-dire en passant une ligne entre chaque point. Les modèles linéaires le font en trouvant la meilleure ligne droite qui passe à travers les données. En revanche, les modèles additifs font cela en ajustant une courbe à travers les données, mais tout en contrôlant le degré de courbure de la ligne (plus d’information sur cela plus bas). "],["introduction-aux-gams.html", "Chapitre 4 Introduction aux GAMs 4.1 DÉFI 1", " Chapitre 4 Introduction aux GAMs Examinons un exemple. Premièrement, nous allons générer des données et les représenter graphiquement. library(ggplot2) set.seed(10) n = 250 x = runif(n, 0, 5) y_model = 3 * x/(1 + 2 * x) y_obs = rnorm(n, y_model, 0.1) data_plot = qplot(x, y_obs) + geom_line(aes(y = y_model)) + theme_bw() print(data_plot) Si nous modélisions cette relation par une régression linéaire, les résultats ne respecteraient pas les suppositions énumérées ci-dessus. Commençons par modéliser une régression en utilisant la méthode des moindres carrés en utilisant la fonction gam() de la librairie mgcv - donc en tant que modèle linéaire (nous verrons plus bas comment utiliser cette fonction pour spécifier un terme non linéaire). library(mgcv) linear_model = gam(y_obs ~ x) model_summary = summary(linear_model) print(model_summary) data_plot = data_plot + geom_line(colour = &quot;red&quot;, aes(y = fitted(linear_model))) print(data_plot) Nous pouvons constater à partir du sommaire que notre modèle linéaire explique une grande partie de la variance (R2adj = 0.639). Toutefois, les graphiques de diagnostic des résidus du modèle montrent que l’écart type ne suit pas une distribution normale et que la variance n’est pas homoscédastique. De plus, il reste un patron non-linéaire important. Essayons maintenant de résoudre ce problème en ajustant les données avec un terme non linéaire. Nous reviendrons sur ceci un peu plus tard, mais brièvement, les GAMs sont une forme non paramétrique de la régression où le βxi d’une régression linéaire est remplacé par une fonction de lissage des variables explicatives, f(xi), et le modèle devient : \\[y_i = f(x_i) + ε_i\\] où yi est la variable réponse, xi est la covariable, et f est la fonction lissage. Étant donné que la fonction de lissage f(xi) est non linéaire et locale, l’ampleur de l’effet de la variable explicative peut varier en fonction de la relation entre la variable et la réponse. Autrement dit, contrairement à un coefficient fixe βxi, la fonction f peut changer tout au long du gradient xi. Le degré de lissage de f est contrôlée en utilisant une régression pénalisée qui est déterminée automatiquement à l’aide d’une méthode de validation croisée généralisée (GCV) de la librairie mgcv (Wood 2006). Avec gam() les termes non linéaires sont spécifiés par des expressions de la forme: s(x). gam_model = gam(y_obs ~ s(x)) summary(gam_model) data_plot = data_plot + geom_line(colour = &quot;blue&quot;, aes(y = fitted(gam_model))) print(data_plot) La variance expliquée par notre modèle a augmenté de 20% (R2adj = 0.859) et quand on compare l’ajustement du modèle linéaire (rouge) au modèle non-linéaire (bleu), il est clair que l’ajustement de ce dernier est relativement meilleur. La librairie mgcv comprend également une fonction plot qui, par défaut, nous permet de visualiser la non-linéarité du modèle. plot(gam_model) Comment utilisons-nous les GAMs pour savoir si un modèle linéaire est suffisant pour modéliser nos données ? Nous pouvons utiliser les fonctions gam() et anova() pour tester formellement si une hypothèse de linéarité est justifiée. Nous devons simplement le configurer de sorte que notre modèle non-linéaire est emboîté dans notre modèle linéaire; c’est à dire, nous devons créer un objet qui inclut à la fois x (linéaire) et s(x) (non-linéaire). En utilisant la fonction anova(), on vérifie si l’ajout de s(x) au modèle avec seulement x comme covariable est justifié par les données. linear_model = gam(y_obs ~ x) nested_gam_model = gam(y_obs ~ s(x) + x) print(anova(linear_model, nested_gam_model, test = &quot;Chisq&quot;)) Le terme non linéaire est significatif: Analysis of Deviance Table Model 1: y_obs ~ x Model 2: y_obs ~ s(x) + x Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) 1 248.00 6.5846 2 240.68 2.4988 7.3168 4.0858 &lt; 2.2e-16 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 4.1 DÉFI 1 Nous allons maintenant essayer cela avec d’autres données générées aléatoirement. Nous allons d’abord générer les données. Ensuite, nous allons ajuster un modèle linéaire et un GAM à la relation entre x_test et y_test_obs. Quels sont les degrés de libertés effectifs du terme non-linéaire ? Déterminez si l’hypothèse de linéarité est justifiée pour ces données. n &lt;- 250 x_test &lt;- runif(n, -5, 5) y_test_fit &lt;- 4 * dnorm(x_test) y_test_obs &lt;- rnorm(n, y_test_fit, 0.2) 4.1.1 Réponse au défi 1 data_plot &lt;- qplot(x_test, y_test_obs) + geom_line(aes(y = y_test_fit)) + theme_bw() print(data_plot) linear_model_test &lt;- gam(y_test_obs ~ x_test) nested_gam_model_test &lt;- gam(y_test_obs ~ s(x_test) + x_test) print(anova(linear_model_test, nested_gam_model_test, test = &quot;Chisq&quot;)) summary(nested_gam_model_test)$s.table Analysis of Deviance Table Model 1: y_test_obs ~ x_test Model 2: y_test_obs ~ s(x_test) + x_test Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) 1 248.0 81.09 2 240.5 7.46 7.5012 73.629 &lt; 2.2e-16 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 edf Ref.df F p-value s(x_test) 7.602145 8.029057 294.0944 0 Réponse: Oui la non-linéarité est justifiée. Les degrés de libertés effectifs (edf) sont &gt;&gt; 1. "],["plusieurs-termes-non-linéaires.html", "Chapitre 5 Plusieurs termes non linéaires 5.1 DÉFI 2", " Chapitre 5 Plusieurs termes non linéaires Avec les GAMs, il est facile d’ajouter des termes non linéaires et linéaires dans un seul modèle, plusieurs termes non linéaires ou même des interactions non linéaires. Dans cette section, nous allons utiliser un ensemble de données générées automatiquement par mgcv. gam_data = gamSim(eg = 5) head(gam_data) Nous allons voir comment nous pouvons prédire la variable réponse y en fonction des autres variables. Commençons par un modèle de base comprenant un terme non linéaire (x1) et un facteur qualitatif (X0 avec 4 niveaux). basic_model = gam(y ~ x0 + s(x1), data = gam_data) basic_summary = summary(basic_model) print(basic_summary$p.table) print(basic_summary$s.table) plot(basic_model) Ici, la sortie de p.table fournit le tableau de résultats pour chaque terme paramétrique et le tableau s.table nous donne les résultats du terme non linéaire. Notez que pour le second tableau, la courbure du terme non linéaire s(X1) est indiquée par le paramètre edf (degrés de libertés effectifs); plus la valeur de l’edf est élevée, plus la non-linéarité est forte. Une valeur élevée (8-10 ou plus) signifie que la courbe est fortement non linéaire, alors qu’une courbe avec un edf égal à 1 est une ligne droite. En revanche, dans la régression linéaire, les degrés de libertés du modèle sont équivalents au nombre de paramètres libres non redondants p dans le modèle (et les degrés de libertés résiduels sont égaux à n-p). Nous reviendrons plus tard sur le concept d’edf. print(basic_summary$p.table) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 8.550030 0.3655849 23.387258 1.717989e-76 x02 2.418682 0.5165515 4.682364 3.908046e-06 x03 4.486193 0.5156501 8.700072 9.124666e-17 x04 6.528518 0.5204234 12.544629 1.322632e-30 &gt; print(basic_summary$s.table) edf Ref.df F p-value s(x1) 1.923913 2.406719 42.84268 1.076396e-19 Dans notre modèle de base, l’edf du terme non linéaire s(x1) est ~ 2, ce qui indique une courbe non linéaire. Le graphique du modèle illustre bien la forme de ce terme non linéaire : Nous pouvons ajouter un second terme x2, mais spécifier une relation linéaire avec Y (i.e. les GAMs peuvent inclure à la fois des termes linéaires et non linéaires dans le même modèle). Ce nouveau terme linéaire x2 sera présenté dans le tableau p.table, pour lequel une estimation du coefficient de régression sera indiquée. Dans le tableau s.table, nous retrouvons encore une fois le terme non linéaire s(x1) et son paramètre de courbure. two_term_model &lt;- gam(y ~ x0 + s(x1) + x2, data = gam_data) two_term_summary &lt;- summary(two_term_model) print(two_term_summary$p.table) print(two_term_summary$s.table) Pour évaluer si la relation entre y et x2 est non linéaire, on peut modéliser x2 avec une fonction non linéaire. Tel que vu auparavant, nous pouvons utiliser une ANOVA pour tester si le terme non linéaire est nécessaire. two_smooth_model &lt;- gam(y ~ x0 + s(x1) + s(x2), data = gam_data) two_smooth_summary &lt;- summary(two_smooth_model) print(two_smooth_summary$p.table) print(two_smooth_summary$s.table) plot(two_smooth_model, page = 1) Lorsqu’il y a plus d’une variable d’incluse dans le modèle, comme ci-dessus, la réponse ajustée peut-être partitionnée entre les contributions de chaque variable. Ici, nous pouvons évaluer l’effet de chaque variable où l’axe des ordonnées représente la contribution (effet) de chaque covariable à la réponse ajustée centrée sur 0. Si l’intervalle de confiance chevauche zéro pour certaines valeurs de x, cela indique que l’effet est non significatif. Lorsque la contribution varie selon l’axe x, un changement de cette variable cause un changement de la variable réponse. anova(basic_model, two_term_model, two_smooth_model, test = &quot;Chisq&quot;) Analysis of Deviance Table Model 1: y ~ x0 + s(x1) Model 2: y ~ x0 + s(x1) + x2 Model 3: y ~ x0 + s(x1) + s(x2) Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) 1 394.08 5231.6 2 393.10 4051.3 0.97695 1180.2 &lt; 2.2e-16 *** 3 385.73 1839.5 7.37288 2211.8 &lt; 2.2e-16 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Le meilleur modèle est le modèle avec deux fonctions non linéaires pour x1 et pour x2. 5.1 DÉFI 2 Créez deux nouveaux modèles avec la variable x3 : un modèle avec x3 comme paramètre linéaire et un autre modèle avec x3 avec un paramètre non linéaire. Utilisez des graphiques, les tables des coefficients et la fonction anova() afin de déterminer s’il est nécessaire d’inclure x3 dans le modèle. 5.1.1 Réponse au défi 2 three_term_model &lt;- gam(y ~ x0 + s(x1) + s(x2) + x3, data = gam_data) three_smooth_model &lt;- gam(y ~ x0 + s(x1) + s(x2) + s(x3), data = gam_data) three_smooth_summary &lt;- summary(three_smooth_model) print(three_smooth_summary$p.table) print(three_smooth_summary$s.table) plot(three_smooth_model, page = 1) # edf = 1 -&gt; le terme est donc linéaire. anova(two_smooth_model, three_term_model, test = &quot;Chisq&quot;) # le terme x3 n&#39;est pas significatif "],["interactions.html", "Chapitre 6 Interactions", " Chapitre 6 Interactions Il y a deux façons de modéliser une interaction entre deux variables: si une variable est quantitative et l’autre est qualitative, on utilise l’argument by → s(x, by=facteur), si les deux variables sont quantitatives, on inclut les deux termes sous une même fonction non linéaire → s(x1, x2). L’argument by permet de faire varier un terme non linéaire selon les différents niveaux d’un facteur. Nous allons examiner ceci en utilisant notre variable qualitative x0 et examiner si la non-linérité de s(x2) varie selon les différents niveaux de x0. Pour déterminer si les courbes diffèrent significativement entre les niveaux du facteur, nous allons utiliser une ANOVA sur l’interaction. categorical_interact &lt;- gam(y ~ x0 + s(x1) + s(x2, by = x0), data = gam_data) categorical_interact_summary &lt;- summary(categorical_interact) print(categorical_interact_summary$s.table) plot(categorical_interact, page = 1) # ou nous pouvons utiliser la fonction vis.gam où theta # représente la rotation du plan x-y vis.gam(categorical_interact, view = c(&quot;x2&quot;, &quot;x0&quot;), theta = 40, n.grid = 500, border = NA) anova(two_smooth_model, categorical_interact, test = &quot;Chisq&quot;) Nous pouvons constater à partir du graphique que les formes des termes non linéaires sont comparables entre les quatre niveaux de x0. L’ANOVA le confirme également (déviance = 98,6, p = 0,2347). Ensuite, nous allons examiner l’interaction non linéaire entre deux termes quantitatifs, x1 et x2. Cette fois-ci, l’argument by est supprimé. smooth_interact &lt;- gam(y ~ x0 + s(x1, x2), data = gam_data) smooth_interact_summary &lt;- summary(smooth_interact) print(smooth_interact_summary$s.table) plot(smooth_interact, page = 1, scheme = 3) # plot(smooth_interact,page=1,scheme=1) donne un graphique # comparable à vis.gam() vis.gam(smooth_interact, view = c(&quot;x1&quot;, &quot;x2&quot;), theta = 40, n.grid = 500, border = NA) anova(two_smooth_model, smooth_interact, test = &quot;Chisq&quot;) L’interaction entre s(x1) et s(x2) est significative et le graphique en deux dimensions illustre très bien cette interaction non linéaire. La relation entre y et x1 change en fonction de la valeur de x2. Vous pouvez changez la valeur de l’argument theta pour tourner l’axe du graphique. Si vous prévoyez exécuter un grand nombre de graphiques, supprimez l’argument n.grid = 500, car ceci fait appel à des calculs intensifs et ralentit R. "],["changer-la-fonction-de-base.html", "Chapitre 7 Changer la fonction de base", " Chapitre 7 Changer la fonction de base Sans entrer dans le détail, sachez qu’il est possible de modifier le modèle de base que nous avons vu avec : des fonctions plus complexes en modifiant la fonction de base (par exemple, cyclique), d’autres distributions : tout ce que vous pouvez faire avec un GLM (tel que spécifier l’argument family) est possible avec les GAMs, des modèles à effets mixtes en utilisant la fonction gamm ou la fonction gamm4 de la librairie gamm4. Nous allons d’abord jeter un coup d’œil au changement de la fonction de base puis une introduction rapide aux autres distributions et les GAMMs (modèles additifs généralisés à effets mixtes) suivra. Commençons par regarder un cas où modifier la fonction de base peut être utile, soit avec des données cycliques. Imaginez que vous avez une série temporelle de données climatiques, divisées en mesures mensuelles, et que vous voulez déterminer s’il y a une tendance de température annuelle. Nous allons utiliser la série temporelle de température de Nottingham pour cette section : data(nottem) n_years &lt;- length(nottem)/12 nottem_month &lt;- rep(1:12, times = n_years) nottem_year &lt;- rep(1920:(1920 + n_years - 1), each = 12) nottem_plot &lt;- qplot(nottem_month, nottem, colour = factor(nottem_year), geom = &quot;line&quot;) + theme_bw() print(nottem_plot) En utilisant les données nottem, nous avons créé trois nouveaux vecteurs ; n_years correspond au nombre d’années de données (20 ans), nottem_month est un codage qualitatif pour les 12 mois de l’année, pour chaque année échantillonnée (série de 1 à 12, répétée 20 fois) et nottem_year est une variable où l’année correspondant à chaque mois est fournie. Données mensuelles des années 1920 à 1940: Pour modéliser cela, nous devons utiliser ce qu’on appelle un spline cubique cyclique, ou \"cc\", pour modéliser les effets du mois et de l’année. year_gam &lt;- gam(nottem ~ s(nottem_year) + s(nottem_month, bs = &quot;cc&quot;)) summary(year_gam)$s.table plot(year_gam, page = 1, scale = 0) Il y a une hausse d’environ 1 - 1,5ºC au cours de la série, mais au cours d’une année, il y a une variation d’environ 20ºC. Les données réelles varient autour de ces valeurs prédites et ceci représente donc la variance inexpliquée. Ici, nous pouvons voir l’un des avantages très intéressants de l’utilisation des GAMs. Nous pouvons soit tracer la surface réponse (valeurs prédites) ou les termes (contribution de chaque covariable) tel qu’indiqué ci-haut. Vous pouvez imaginer ce dernier en tant qu’une illustration de la variation des coefficients de régression et comment leur contribution (ou taille de leur effet) varie au fil du temps. Dans le premier graphique, nous voyons que les contributions positives de la température sont survenues après 1930. Sur des échelles de temps plus longues, en utilisant par exemple des données paléolimnologiques, d’autres (Simpson &amp; Anderson 2009;. Fig 3c) ont utilisé des GAMs pour tracer la contribution (effet) de la température sur la composition d’algues dans les lacs afin d’illustrer comment les contributions significatives ont seulement eu lieu au cours de deux périodes extrêmement froides (c’est-à-dire, la contribution est importante lorsque les intervalles de confiance ne recoupent pas la valeur de zéro à environ 300 et 100 ans AVJC). Cela a permis aux auteurs de non seulement déterminer combien de variance est expliquée par la température au cours des derniers siècles, mais aussi de repérer dans le temps cet effet significatif. Si cela vous intéresse, le code pour tracer soit la surface de réponse (type = \"response\") ou les termes (type = \"terms\") est disponible ci-dessous. Lorsque les termes sont sélectionnés, vous obtiendrez la même figure que celle ci-dessus. Graphique de contribution vs réponse ajustée: pred &lt;- predict(year_gam, type = &quot;terms&quot;, se = TRUE) I &lt;- order(nottem_year) plusCI &lt;- I(pred$fit[, 1] + 1.96 * pred$se[, 1]) minusCI &lt;- I(pred$fit[, 1] - 1.96 * pred$se[, 1]) xx &lt;- c(nottem_year[I], rev(nottem_year[I])) yy &lt;- c(plusCI[I], rev(minusCI[I])) plot(xx, yy, type = &quot;n&quot;, cex.axis = 1.2) polygon(xx, yy, col = &quot;light grey&quot;, border = &quot;light grey&quot;) lines(nottem_year[I], pred$fit[, 1][I], lty = 1) abline(h = 0) "],["autres-distributions.html", "Chapitre 8 Autres distributions 8.1 Visualiser la tendance au fil du temps", " Chapitre 8 Autres distributions Pour vous donner un bref aperçu de l’utilisation des GAMs lorsque la variable réponse ne suit pas une distribution normale ou que les données sont des abondances ou proportions (par exemple, distribution Gamma, binomiale, Poisson, binomiale négative), l’exemple qui suit utilise un ensemble de données où une répartition binomiale sera nécessaire, y compris une modélisation d’une relation non linéaire. La variable réponse représente le nombre de succès (l’événement a eu lieu) en fonction des défaillances au cours d’une expérience. gam_data3 &lt;- read.csv(&quot;other_dist.csv&quot;) summary(gam_data3) str(gam_data3) &#39;data.frame&#39;: 514 obs. of 4 variables: $ prop : num 1 1 1 1 0 1 1 1 1 1 ... $ total: int 4 20 20 18 18 18 20 20 20 20 ... $ x1 : int 550 650 750 850 950 650 750 850 950 550 ... $ fac : Factor w/ 4 levels &quot;f1&quot;,&quot;f2&quot;,&quot;f3&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... prop est la variable réponse, égal à la proportion de succès / (succès + échecs). Notez qu’il existe de nombreux cas où la proportion est égal à 1 ou 0 qui indique que les résultats ont toujours été des succès ou des échecs, respectivement, à ce moment mesuré durant l’expérience. x1 est le temps écoulé depuis le début de l’expérience (variable explicative). total représente le nombre de succès + échecs observé au moment x1i de l’expérience. fac est un facteur qui code pour l’essai 1 à 4 de l’expérience (nous n’utiliserons pas cette variable dans cette section). Commençons par la visualisation des données. Nous sommes intéressés par le nombre de succès par rapport aux échecs à mesure que x1 augmente. Étant donné qu’il y a des mesures répétées pour la valeur de x1 (essais 1 à 4, avec nombreuses observations par essai), nous pouvons d’abord présenter la proportion de succès en moyenne par boîte de temps (x1): emptyPlot(range(gam_data3$x1), c(0, 1), h = 0.5, main = &quot;Probability of successes&quot;, ylab = &quot;Probability&quot;, xlab = &quot;x1&quot;) avg &lt;- aggregate(prop ~ x1, data = gam_data3, mean, na.rm = TRUE) lines(avg$x1, avg$prop, col = &quot;orange&quot;, lwd = 2) Notez comment la probabilité de succès augmente avec x1. D’après vous, est-ce que cette tendance est linéaire ou non linéaire? Nous allons tester cela en utilisant un GAM logistique (nous utilisons une distribution binomiale puisque la variable réponse représente des proportions). prop_model &lt;- gam(prop ~ s(x1), data = gam_data3, weights = total, family = &quot;binomial&quot;) prop_summary &lt;- summary(prop_model) print(prop_summary$p.table) print(prop_summary$s.table) plot(prop_model) Estimate Std. Error z value Pr(&gt;|z|) (Intercept) 1.173978 0.02709613 43.32641 0 edf Ref.df Chi.sq p-value s(x1) 4.591542 5.615235 798.9407 2.027751e-164 Qu’est-ce que l’ordonnée représente dans ce modèle? Rappel : le modèle utilise le nombre de succès vs échecs pour calculer le logit, qui est le logarithme du rapport entre les succès et échecs: $\\(logit = log(\\frac{N_{success}}{N_{failures}})\\)$ Si succès = échecs, le rapport est de 1 et le logit est 0 (log (1) = 0). Si les succès ont un nombre plus grand que les échecs, le ratio est supérieur à 1 et le logit a une valeur positive (par exemple, log(2) = 0,69). Si les succès ont un nombre plus petit que les échecs, le ratio est inférieur à 1 et le logit a une valeur négative (par exemple, log(0,5) = -0.69). Donc, l’ordonnée est le logit, et indique s’il y a en moyenne plus de succès que d’échecs. Ici, l’estimé est positif ce qui signifie, qu’en moyenne, il n’y a plus de succès que d’échecs. Qu’est-ce que le terme de lissage indique? Ceci représente la façon dont les chances de succès vs échecs changent sur l’échelle de x1 (l’échelle du temps dans cet exemple). Donc, puisque l’edf &gt; 1, la proportion de succès augmente plus rapidement au fil du temps (si par exemple, la réponse représente le nombre d’individus de l’espèce A vs l’espèce B et que nous augmentons la concentration des nutriments au fil du temps, ces résultats indiqueront que l’espèce A est de plus en plus observée alors que les concentrations de nutriments approchent de l’optimum de cette espèce au cours de l’expérience). 8.1 Visualiser la tendance au fil du temps Enfin, nous allons voir les différentes façons de représenter ces relations graphiquement. par(mfrow = c(1, 2)) plot(prop_model, select = 1, scale = 0, shade = TRUE) abline(h = 0) plot_smooth(prop_model, view = &quot;x1&quot;, main = &quot;&quot;) (diff &lt;- find_difference(out$fv$fit, out$fv$CI, xVals = out$fv$x1)) addInterval(0, lowVals = diff$start, highVals = diff$end, col = &quot;red&quot;, lwd = 2) abline(v = c(diff$start, diff$end), lty = 3, col = &quot;red&quot;) text(mean(c(diff$start, diff$end)), 2.1, &quot;sign. more \\n success&quot;, col = &quot;red&quot;, font = 3) Quels renseignements ces graphiques nous apportent-ils vis à vis les succès et échecs ? Graphique de gauche : contribution (ou effet partiel si nous avions plus qu’une variable explicative) au fil du temps. La valeur logit augmente, donc les succès augmentent et les échecs diminuent. Graphique de droite : valeurs ajustées, ordonnée incluse (somme des effets si nous avions plus d’une variable explicative dans le modèle). Nous voyons ici que la valeur logit est estimée près de zéro au début de l’expérience ; cela signifie qu’il y a des quantités égales de succès et d’échecs. Peu à peu, les succès augmentent et à environ x1 = 400 il y a beaucoup plus de succès que d’échecs (l’effet est significativement différent de zéro). Nous avons également montré comment nous pouvons utiliser le graphique pour déterminer à quelle valeur de x1 cela se produit. Enfin, pour nous aider à interpréter les résultats, nous pouvons re-transformer l’effet sur une échelle de proportions avec la fonction plot_smooth de la librairie itsadug: par(mfrow = c(1, 1)) plot_smooth(prop_model, view = &quot;x1&quot;, main = &quot;&quot;, transform = plogis, ylim = c(0, 1)) abline(h = 0.5, v = diff$start, col = &quot;red&quot;, lty = 2) Comme nous l’avons déjà vu avec le graphique précédent des valeurs logits, nous voyons qu’à approximativement x1 = 400 la proportion de succès augmente de façon significative au-dessus de 0,5. "],["intro-rapide-aux-modèles-additifs-généralisés-à-effets-mixtes-gamms.html", "Chapitre 9 Intro rapide aux modèles additifs généralisés à effets mixtes (GAMMs) 9.1 La non-indépendance des données 9.2 Modélisation avec effets mixtes", " Chapitre 9 Intro rapide aux modèles additifs généralisés à effets mixtes (GAMMs) 9.1 La non-indépendance des données Lorsque les observations ne sont pas indépendantes, les GAMs peuvent être utilisés soit pour incorporer: une structure de corrélation pour modéliser les résidus autocorrélés (autorégressif (AR), moyenne mobile (MA), ou une combinaison des deux (ARMA)) des effets aléatoires qui modélisent l’indépendance entre les observations d’un même site. En plus de changer la fonction de base, nous pouvons aussi complexifier le modèle en intégrant une structure d’auto-corrélation (ou même des effets mixtes) en utilisant les fonctions gamm ou gamm4. Pour commencer, nous allons jeter un coup d’œil au premier cas ; un modèle avec autocorrélation temporelle dans les résidus. Ré-examinons le modèle de la température de Nottingham; nous allons vérifier si les résidus sont corrélés en faisant appel à la fonction (partielle) d’autocorrélation. par(mfrow = c(1, 2)) acf(resid(year_gam), lag.max = 36, main = &quot;ACF&quot;) pacf(resid(year_gam), lag.max = 36, main = &quot;pACF&quot;) Les graphiques des fonctions d’autocorrélation suggèrent qu’un modèle AR de faible ordre est nécessaire (avec un ou deux intervalles de temps décalés), donc nous pouvons évaluer deux modèles; ajouter un AR(1) ou un AR(2) au modèle de la température de Nottingham et évaluer le meilleur avec une ANOVA. year_gam &lt;- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = &quot;cc&quot;)) year_gam_AR1 &lt;- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = &quot;cc&quot;), correlation = corARMA(form = ~1 | nottem_year, p = 1)) year_gam_AR2 &lt;- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = &quot;cc&quot;), correlation = corARMA(form = ~1 | nottem_year, p = 2)) anova(year_gam$lme, year_gam_AR1$lme, year_gam_AR2$lme) Model df AIC BIC logLik Test L.Ratio p-value year_gam$lme 1 5 1109.908 1127.311 -549.9538 year_gam_AR1$lme 2 6 1101.218 1122.102 -544.6092 1 vs 2 10.689206 0.0011 year_gam_AR2$lme 3 7 1101.598 1125.962 -543.7988 2 vs 3 1.620821 0.2030 Le modèle avec la structure AR(1) prévoit une augmentation significative comparativement au premier modèle (LRT = 10,69, p = 0,0011), mais il y a très peu d’intérêt à considérer le modèle AR(2) (LRT = 1,62, p = 0,203). 9.2 Modélisation avec effets mixtes Comme nous l’avons vu dans la section précédente, bs spécifie la fonction de base sous-jacente. Pour les facteurs aléatoires (origine et pente linéaire), nous utilisons bs = \"re\" et pour les pentes aléatoires non linéaires, nous utilisons bs = \"fs\". Trois types d’effets aléatoires différents sont possibles lors de l’utilisation des GAMMs (où fac représente une variable qualitative utilisée pou l’effet aléatoire et x0 est un effet quantitatif fixe) : interceptes aléatoires ajustent la hauteur des termes du modèle avec une valeur constante de pente : s(fac, bs=\\\"re\\\") pentes aléatoires ajustent la pente d’une variable explicative numérique: s(fac, x0, bs=\\\"re\\\") surfaces lisses aléatoires ajustent la tendance d’une prédiction numérique de façon non linéaire: s(x0, fac, bs=\\\"fs\\\", m=1) où l’argument m=1 met une plus grande pénalité au lissage qui s’éloigne de 0, ce qui entraîne un retrait vers la moyenne. Nous examinerons d’abord un GAMM avec un interception aléatoire. Tel que vu précédemment, nous allons utiliser gamSim() pour générer un ensemble de données, cette fois-ci avec une composante d’effet aléatoire. Ensuite, nous construirons un modèle avec un intercepte aléatoire en utilisant fac comme facteur aléatoire. # Générez des données gam_data2 &lt;- gamSim(eg = 6) head(gam_data2) # Faites rouler un modèle avec intercepte aléatoire gamm_intercept &lt;- gam(y ~ s(x0) + s(fac, bs = &quot;re&quot;), data = gam_data2) summary(gamm_intercept) Notez le terme aléatoire dans le tableau. Vous pouvez le visualiser: plot(gamm_intercept, select = 2) # select=2 parce que le terme aléatoire se trouve sur la 2e # ligne du tableau sommaire. Une fonction de traçage vraiment intéressante que nous allons maintenant utiliser est le plot_smooth de la librairie itsadug. Contrairement au graphique par défaut plot.gam, cette fonction présente l’effet additionné du GAMM avec l’option de ne pas inclure les courbes aléatoires dans le graphique. Ici, nous allons premièrement tracer l’effet combiné de x0 (sans les niveaux de l’effet aléatoire) et ensuite une courbe pour les quatre niveaux de fac: par(mfrow = c(1, 2), cex = 1.1) plot_smooth(gamm_intercept, view = &quot;x0&quot;, rm.ranef = TRUE, main = &quot;intercept + s(x1)&quot;, rug = FALSE) plot_smooth(gamm_intercept, view = &quot;x0&quot;, cond = list(fac = &quot;1&quot;), main = &quot;... + s(fac)&quot;, col = &quot;orange&quot;, ylim = c(8, 21), rug = FALSE) plot_smooth(gamm_intercept, view = &quot;x0&quot;, cond = list(fac = &quot;2&quot;), add = TRUE, col = &quot;red&quot;) plot_smooth(gamm_intercept, view = &quot;x0&quot;, cond = list(fac = &quot;3&quot;), add = TRUE, col = &quot;purple&quot;) plot_smooth(gamm_intercept, view = &quot;x0&quot;, cond = list(fac = &quot;4&quot;), add = TRUE, col = &quot;turquoise&quot;) Ensuite, nous allons générer et tracer un modèle avec une pente aléatoire : gamm_slope &lt;- gam(y ~ s(x0) + s(x0, fac, bs = &quot;re&quot;), data = gam_data2) summary(gamm_slope) plot_smooth(gamm_slope, view = &quot;x0&quot;, rm.ranef = TRUE, main = &quot;intercept + s(x0)&quot;, rug = FALSE) plot_smooth(gamm_slope, view = &quot;x0&quot;, cond = list(fac = &quot;1&quot;), main = &quot;... + s(fac)&quot;, col = &quot;orange&quot;, ylim = c(7, 22), rug = FALSE) plot_smooth(gamm_slope, view = &quot;x0&quot;, cond = list(fac = &quot;2&quot;), add = TRUE, col = &quot;red&quot;) plot_smooth(gamm_slope, view = &quot;x0&quot;, cond = list(fac = &quot;3&quot;), add = TRUE, col = &quot;purple&quot;) plot_smooth(gamm_slope, view = &quot;x0&quot;, cond = list(fac = &quot;4&quot;), add = TRUE, col = &quot;turquoise&quot;) Nous allons maintenant inclure à la fois un intercepte et une pente aléatoires. gamm_int_slope &lt;- gam(y ~ s(x0) + s(fac, bs = &quot;re&quot;) + s(fac, x0, bs = &quot;re&quot;), data = gam_data2) summary(gamm_int_slope) plot_smooth(gamm_int_slope, view = &quot;x0&quot;, rm.ranef = TRUE, main = &quot;intercept + s(x0)&quot;, rug = FALSE) plot_smooth(gamm_int_slope, view = &quot;x0&quot;, cond = list(fac = &quot;1&quot;), main = &quot;... + s(fac) + s(fac, x0)&quot;, col = &quot;orange&quot;, ylim = c(7, 22), rug = FALSE) plot_smooth(gamm_int_slope, view = &quot;x0&quot;, cond = list(fac = &quot;2&quot;), add = TRUE, col = &quot;red&quot;, xpd = TRUE) plot_smooth(gamm_int_slope, view = &quot;x0&quot;, cond = list(fac = &quot;3&quot;), add = TRUE, col = &quot;purple&quot;, xpd = TRUE) plot_smooth(gamm_int_slope, view = &quot;x0&quot;, cond = list(fac = &quot;4&quot;), add = TRUE, col = &quot;turquoise&quot;, xpd = TRUE) Notez que les pentes aléatoires sont statique : plot(gamm_int_slope, select = 3) # select=3 parce que la pente aléatoire se trouve sur la 3e # ligne du tableau sommaire. Enfin, nous allons examiner un modèle avec une surface lisse aléatoire. gamm_smooth &lt;- gam(y ~ s(x0) + s(x0, fac, bs = &quot;fs&quot;, m = 1), data = gam_data2) summary(gamm_smooth) Ici, si les pentes aléatoires variaient selon x0, nous auront vue des courbe variable pour chaque niveau : plot(gamm_smooth, select = 1) # select=1 parce que le terme se trouve sur la 1e ligne du # tableau sommaire. Finalement, tous ces modèles mixes peuvent être compare en utilisant la fonction anova() pour trouver le meilleur modèle. "],["les-gams-en-coulisse.html", "Chapitre 10 Les GAMs en coulisse 10.1 Un exemple simple : une base polynomiale 10.2 Un autre exemple : une base de spline cubique 10.3 Illustration du principe de validation croisée 10.4 Note supplémentaire sur les degrés de liberté effectifs (edf)", " Chapitre 10 Les GAMs en coulisse Nous allons maintenant prendre quelques minutes pour regarder comment fonctionnent les GAMs. Commençons en considérant d’abord un modèle qui contient une fonction lisse d’une covariable, , xi : \\[y_i = f(x_i) + ε_i\\] Pour estimer la fonction f, nous avons besoin de représenter l’équation ci-dessus de manière à ce qu’elle devienne un modèle linéaire. Cela peut être fait en choisissant une base, bi(x), définissant l’espace des fonctions dont f est un élément: \\[f(x) = \\sum_{i=1}^{q}b_i(x)β_i\\] 10.1 Un exemple simple : une base polynomiale Supposons que f est considéré comme un polynôme d’ordre 4, de sorte que l’espace des polynômes d’ordre 4 et moins contiennent f. Une base de cet espace serait alors : \\[b_1(x)=1, b_2(x)=x, b_3(x)=x^2, b_4(x)=x^3, b_5(x)=x^4\\] et f(x) devient : \\[f(x) = β_1 + x_iβ_2 + x^2_iβ_3 + x^3_iβ_4(x) + x^4_iβ_5\\] et le modèle complet devient : \\[y_i = β_1 + x_iβ_2 + x^2_iβ_3 + x^3_iβ_4(x) + x^4_iβ_5 + ε_i\\] Chaque fonction de base est multipliée par un paramètre à valeur réelle, βi, et est ensuite additionnée pour donner la courbe finale f(x). En faisant varier le coefficient βi, on peut faire varier la forme de f(x) pour produire une fonction polynomiale d’ordre 4 ou moins. 10.2 Un autre exemple : une base de spline cubique Un spline cubique est une courbe construite à partir de sections d’un polynôme cubique reliées entre elles de sorte qu’elles sont continues en valeur. Chaque section du spline a des coefficients différents. Voici une représentation d’une fonction lisse utilisant une base de régression spline cubique de rang 5 avec des nœuds situés à incréments de 0,2: Dans cet exemple, les nœuds sont espacés uniformément à travers la gamme des valeurs observées de x. Le choix du degré de finesse du modèle est pré-déterminé par le nombre de noeuds, qui était arbitraire. Y a-t-il une meilleure façon de sélectionner les emplacements des nœuds? 10.2.1 Contrôler le degré de lissage avec des splines de régression pénalisés Au lieu de contrôler le lissage (non linéarité) en modifiant le nombre de nœuds, nous gardons celle-ci fixée à une taille un peu plus grande que raisonnablement nécessaire et on contrôle le lissage du modèle en ajoutant une pénalité sur le niveau de courbure. Donc, plutôt que d’ajuster le modèle en minimisant (comme avec la méthode des moindres carrés) : \\[||y - XB||^2\\] il peut être modélisé en minimisant : \\[||y - XB||^2 + \\lambda \\int_0^1 [f&#39;&#39;(x)]^2 dx\\] Quant λ tend vers ∞, le modèle devient linéaire. Pour la sélection du meilleur paramètre de lissage, λ, on utilise une approche de validation croisée. Si λ est trop élevé, les données seront trop lissées et si elle est trop faible, les données ne seront pas assez lissées. Idéalement, il serait bon de choisir une valeur λ de sorte que le f prédit est aussi proche que possible du f observé. Un critère approprié pourrait être de choisir λ pour minimiser : \\[M = \\frac{1}{n} \\sum_{i=1}^{n}(\\hat{f_i} - f_i)^2\\] Étant donné que f est inconnu, M est estimé en utilisant une technique de validation croisée généralisée qui laisse de côté, à chaque tour, une donnée et estime la capacité moyenne des modèles, construits sur les données restantes, de prédire la donnée qui a été mise de côté (pour plus de détails, consultez Wood 2006). 10.3 Illustration du principe de validation croisée Dans le premier panneau, la courbe correspond à un ajustement faible par rapport aux données et ne fait pas mieux avec le point manquant. Dans le troisième panneau, la courbe ajuste le bruit aussi bien que le signal et la variabilité supplémentaire induite l’amène à prédire la donnée manquante plutôt mal. Dans le deuxième panneau, cependant, nous voyons que l’ajustement de la courbe du signal sous-jacent est très bien, le lissage passe à travers le bruit et la donnée manquante est raisonnablement bien prédite. 10.4 Note supplémentaire sur les degrés de liberté effectifs (edf) Combien de degrés de liberté a un GAM ? Au lieu de fournir la sortie de la validation croisée en termes de λ (un paramètre qui détermine la complexité de l’ajustement), la fonction gam() utilise un terme appelé les degrés de liberté effectifs (edf), de manière cohérente à quantifier la complexité du modèle (pour justifier notre intuition que les degrés de liberté offrent une manière cohérente de quantifier la complexité du modèle). Parce que le nombre de paramètres libres des splines de lissage (tel que les GAMs) est souvent difficile à définir, les edf sont liés à λ, où l’effet de la pénalité est de réduire les degrés de libertés. Donc, si le nombre de noeuds est arbitrairement réglé à k = 10, k-1 définit la limite supérieure des degrés de libertés associés à un terme de lissage. Ce nombre diminue alors que la pénalité lambda augmente jusqu’à ce que le meilleur modèle soit trouvé par validation croisée. "],["references.html", "Chapitre 11 References", " Chapitre 11 References Il existe beaucoup d’information sur les GAMs. Simon Wood, l’auteur de la librairie mgcv, a un site très utile avec des conférences et des notes introductives sur la façon d’utiliser les GAMs : http://people.bath.ac.uk/sw283/mgcv/ Il a aussi écrit un livre, Generalized Additive Models: An Introduction with R, que nous avons utilisé comme référence pour cet atelier. Le matériel de cet atelier a également été obtenu à partir des blogs et des tutoriels suivants : http://www.fromthebottomoftheheap.net/blog/ http://www.sfs.uni-tuebingen.de/~jvanrij/Tutorial/GAMM.html http://www.sfs.uni-tuebingen.de/~jvanrij/LSA2015/AnswersLab2.html Enfin, les pages d’aide, disponibles via ?gam dans R sont une excellente ressource. "]]

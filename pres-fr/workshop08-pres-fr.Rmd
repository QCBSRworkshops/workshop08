---
title: "Workshop 8: Mod√®les additifs g√©n√©ralis√©s"
subtitle: "S√©rie d'ateliers R"
author: "Centre de la Science de la Biodiversit√© du Qu√©bec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
      highlightStyle: github
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  fig.width = 6, fig.height = 6,
  fig.retina = 3,
  fig.align = 'center'
)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```


class: inverse, center, middle

```{r install_pkgs, message=FALSE, warning=FALSE, include=FALSE, results=0}
# Standard procedure to check and install packages and their dependencies, if needed.

list.of.packages <- c("ggplot2", "itsadug", "mgcv")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE) 
  print(paste0("The following package was installed:", new.packages)) 
} else if(length(new.packages) == 0) {
    print("All packages were already installed previously")
  }
```

# ? propos de cet atelier
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=repo&message=dev&color=6f42c1&logo=github)](https://github.com/QCBSRworkshops/workshop08)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=wiki&message=08&logo=wikipedia)](https://wiki.qcbs.ca/r_atelier8)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=08&color=red&logo=html5)](https://qcbsrworkshops.github.io/workshop08/workshop08-fr/workshop08-fr.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=Diapos&message=08&color=red&logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop08/workshop08-fr/workshop08-fr.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&label=script&message=08&color=2a50b8&logo=r)](https://qcbsrworkshops.github.io/workshop08/workshop08-fr/workshop08-fr.R)

---

# Packages requis

* [ggplot2](https://cran.r-project.org/package=ggplot2)
* [itsadug](https://cran.r-project.org/package=itsadug)
* [mgcv](https://cran.r-project.org/package=mgcv)

<br>

```R
install.packages(c('ggplot2', 'itsadug', 'mgcv'))
```

---


# Aper√ßu

1. Le mod√®le lin√©aire ... et o√π il √©choue
2. Introduction aux GAMs
3. Plusieurs termes non lin√©aires
4. Interactions
5. Changer la fonction de base
6. Intro rapide aux GAMMs
7. Autres distributions
8. Les GAMs en coulisse

---
# Objectifs d'apprentissage

1. Utiliser la librairie `mgcv` pour mod√©liser les relations non lin√©aires,
2. √âvaluer la sortie d'un Mod√®le Additif G√©n√©ralis√© (GAM) afin de mieux comprendre nos donn√©es,
3. Utiliser des tests pour d√©terminer si nos relations correspondent √† des mod√®les non lin√©aires ou lin√©aires,
4. Ajouter des interactions non lin√©aires entre les variables explicatives,
5. Comprendre l'id√©e d'une fonction de base (basis function) et la raison pour laquelle √ßa rend les GAMs si puissants !,
6. Comment mod√©liser la d√©pendance dans les donn√©es (autocorr√©lation, structure hi√©rarchique) en utilisant les GAMMs.

---
# Pr√©requis

> Exp√©rience du logiciel R (assez pour √™tre en mesure d'ex√©cuter un script et d'examiner les donn√©es et les objets dans R).

> Une connaissance de base de la r√©gression simple (vous devez savoir ce qu'on entend par une r√©gression lin√©aire et une ANOVA).

---
class: inverse, center, middle
# 1. Le mod√®le lin√©aire

<hr>

## ...et o√π il √©choue

---
# La r√©gression lin√©aire

La r√©gression lin√©aire est ce que la plupart des gens apprennent avant tout en statistiques et est parmi les m√©thodes les plus performantes. Elle nous permet de mod√©liser une variable r√©ponse en fonction de facteurs pr√©dictifs et d'une erreur r√©siduelle.

--
Tel que vu dans l'[atelier sur les mod√®les lin√©aires](http://qcbs.ca/wiki/r_workshop4), la r√©gression fait cependant quatre suppositions importantes :

1. L'erreur est distribu√©e normalement
2. La variance des erreurs est constante
3. Chaque erreur est ind√©pendante des autres (homosc√©dasticit√©)
4. La r√©ponse est lin√©aire: $y = Œ≤_0 + Œ≤_1x$


---
# La r√©gression lin√©aire

Il n'y a qu'une fa√ßon pour qu'un mod√®le lin√©aire soit correctement appliqu√© :

.center[
![](images/linreg.png)
]


---
# La r√©gression lin√©aire

Et pourtant tant de fa√ßons pour qu'il ne le soit pas :

.center[
![:scale 60%](images/linreg_bad.png)
]

---
# La r√©gression lin√©aire

**Quel est le probl√®me et comment le r√©gler?**

Un **mod√®le lin√©aire** essaye d'ajuster la meilleure **droite** qui passe au milieu des donn√©es, cela ne fonctionne donc pas pour tous les jeux de donn√©es.

En revanche, les **GAM** font cela en ajustant une **fonction de lissage non-lin√©aire** √† travers les donn√©es, mais tout en contr√¥lant le degr√© de courbure de la ligne (*plus d'information sur cela plus bas*).

---
class: inverse, center, middle

## 2. Introduction aux GAMs
---
# Generalized Additive Models (GAM)

Examinons un exemple! Nous allons utils√© le jeu de donn√©es `ISIT`.

```{r, eval = FALSE, echo = TRUE}
isit <- read.csv("data/ISIT.csv",sep=';')
head(isit)
```

Ce jeu de donn√©e comporte des mesures de bioluminescence en relation ‡ la profondeur (*depth*), la station de rechercher et la saison (*Season*).

```{r, eval = TRUE, echo = FALSE}
isit <- read.csv("data/ISIT.csv",sep=';')
head(isit)
```

---
# GAM
Prenons que les donnÈes de la deuxiËme saison pour l'instant
```{r, echo = TRUE}
library(ggplot2)
isit2 <- subset(isit,Season==2)

data_plot<-ggplot(isit2, aes(y=Sources, x=SampleDepth)) +
  geom_point() +
  theme_bw()
data_plot
```
---
# GAM

Si nous mod√©lisions la prise en CO2 selon la Sources par une r√©gression lin√©aire, les r√©sultats ne respecteraient pas les suppositions √©num√©r√©es ci-dessus.
```{r, eval=TRUE,echo = FALSE}
library(mgcv)
linear_model <- gam(Sources ~ SampleDepth,data=isit2)
model_summary <- summary(linear_model)
data_plot <- data_plot +
             geom_line(colour = "red", size = 1.2, 
                       aes(y = fitted(linear_model)))
data_plot
```
---
exclude:true
# Mod√®les Additifs G√©n√©ralis√©s (GAMs)

Examinons un exemple! Premi√®rement, nous allons g√©n√©rer des donn√©es et les repr√©senter graphiquement.

```{r, eval = FALSE, echo = TRUE}
library(ggplot2)
set.seed(10)
n <- 250
x <- runif(n,0,5)
y_model <- 3*x/(1+2*x)
y_obs <- rnorm(n,y_model,0.1)
data_plot <- qplot(x, y_obs) +
  geom_line(aes(y=y_model)) +
  theme_bw()
data_plot
```

---
exclude:true
# GAM

```{r, eval = FALSE, echo = FALSE}
library(ggplot2)
set.seed(10)
n <- 250
x <- runif(n,0,5)
y_model <- 3*x/(1+2*x)
y_obs <- rnorm(n,y_model,0.1)
data_plot <- qplot(x, y_obs) +
  geom_line(aes(y=y_model)) +
  theme_bw()
data_plot
```


---
exclude:true
# GAM

Si nous mod√©lisions cette relation par une r√©gression lin√©aire, les r√©sultats ne respecteraient pas les suppositions √©num√©r√©es ci-dessus.

```{r,eval=FALSE,echo = FALSE}
library(mgcv)
linear_model <- gam(y_obs ~ x)
model_summary <- summary(linear_model)
data_plot <- data_plot +
             geom_line(colour = "red", size = 1.2, aes(y = fitted(linear_model)))
data_plot
```

---
# GAM

Dans un GAM, la relation entre la variable r√©ponse et le pr√©dicteur est :

$$y = \alpha + s(x_1) + s(x_2) + ... + \varepsilon$$

Un des grands avantages d'utiliser un GAM est que la forme optimale de la non-lin√©arit√©, i.e. le degr√© de lissage de `s(x)`, est contr√¥l√©e en utilisant une r√©gression p√©nalis√©e qui est d√©termin√©e automatiquement √† l'aide d'une m√©thode de validation crois√©e g√©n√©ralis√©e.

---
#GAM
Essayons de mod√©liser les donn√©es √† l'aide d'une fonction de lissage avec la fonction `mgcv::gam()`


```{r, eval = FALSE,echo=TRUE}
library(mgcv)
gam_model <- gam(Sources ~ s(SampleDepth),data=isit2)
summary(gam_model)

data_plot <- data_plot +
     geom_line(colour = "blue", size = 1.2, aes(y = fitted(gam_model)))
data_plot
```
---
# GAM

```{r, eval=TRUE, echo = FALSE}
gam_model <- gam(Sources ~ s(SampleDepth),data=isit2)
summary(gam_model)
```

---
# GAM

```{r, eval=TRUE,echo = FALSE}
data_plot <- data_plot +
     geom_line(colour = "blue", size = 1.2, aes(y = fitted(gam_model)))
data_plot
```

.comment[Note: contrairement √† un coefficient fixe $Œ≤$, la fonction de lissage peut changer tout au long du gradient $x$]

---
exclude:true
# GAM

Essayons de mod√©liser les donn√©es √† l'aide d'une fonction de lissage avec la fonction `mgcv::gam()`

```{r, eval = FALSE}
library(mgcv)
gam_model <- gam(y_obs ~ s(x))
summary(gam_model)

data_plot <- data_plot +
     geom_line(colour = "blue", size = 1.2, aes(y = fitted(gam_model)))
data_plot
```

---
exclude:true
# GAM

```{r, echo = FALSE,eval=FALSE}
gam_model <- gam(y_obs ~ s(x))
summary(gam_model)
```

---
exclude:true
# GAM

```{r, echo = FALSE,eval=FALSE}
data_plot <- data_plot +
     geom_line(colour = "blue", size = 1.2, aes(y = fitted(gam_model)))
data_plot
```

.comment[Note: contrairement √† un coefficient fixe $Œ≤$, la fonction de lissage peut changer tout au long du gradient $x$]


---
# GAM

La librairie `mgcv` comprend √©galement une fonction plot qui, par d√©faut, nous permet de visualiser la non-lin√©arit√© du mod√®le :

```{r, fig.width=5.5, fig.height=5.5}
plot(gam_model)
```

---
# Test for linearity using GAM

Nous pouvons utiliser les fonctions `gam()` et `anova()` pour tester formellement si une hypoth√®se de lin√©arit√© est justifi√©e. Nous devons simplement le configurer de sorte que notre mod√®le non-lin√©aire soit embo√Æt√© dans notre mod√®le lin√©aire.

```{r}
linear_model <- gam(Sources ~ SampleDepth,data=isit2) # fit a regular linear model using gam()
nested_gam_model <- gam(Sources ~ s(SampleDepth) + SampleDepth,data=isit2)
AIC(linear_model, nested_gam_model)
```

**Le modËle linÈaire ‡ un AIC plus ÈlevÈ, donc l'hypoth√®se de lin√©arit√© n'est pas accept√©e.**

.comment[Not√© que le mod√®le `y~s(x)` donne exactement le m√™me r√©sultat que `y~s(x)+x`. Nous avons utilis√© s(x)+x pour illustrer l'embo√Ætement du mod√®le, mais +x peut √™tre omis.]

---
exclude:true
# Test de lin√©arit√© avec GAM

Nous pouvons utiliser les fonctions `gam()` et `anova()` pour tester formellement si une hypoth√®se de lin√©arit√© est justifi√©e. Nous devons simplement le configurer de sorte que notre mod√®le non-lin√©aire soit embo√Æt√© dans notre mod√®le lin√©aire.

```{r,eval=FALSE}
linear_model <- gam(y_obs ~ x) # ajuster un mod√®le lin√©aire r√©gulier avec gam()
nested_gam_model <- gam(y_obs ~ s(x) + x)
AIC(linear_model, nested_gam_model, test = "Chisq")
```

---
exclude:true
# Test de lin√©arit√© avec GAM

```{r,eval=FALSE}
linear_model <- gam(y_obs ~ x) # ajuster un mod√®le lin√©aire r√©gulier avec gam()
nested_gam_model <- gam(y_obs ~ s(x) + x)
AIC(linear_model, nested_gam_model, test = "Chisq")
```

.comment[Notez que le mod√®le `y_obs~s(x)` donne exactement les m√™me r√©sultats que `y_obs~s(x)+x`. Nous utilisons $s(x)+x$ pour illustrer l'imbrication du mod√®le, mais le $+x$ peut √™tre omis.]

---
# D√©fi 1 ![:cube]()

Nous allons maintenant essayer cela avec les donn√©es du Mississpi.

```{r}
isit1 <- subset(isit,Season==1)
```


1. Ajustez un mod√®le lin√©aire et un GAM √† la relation entre `Sources` et `SampleDepth`.
2. D√©terminez si l'hypoth√®se de lin√©arit√© est justifi√©e pour ces donn√©es.
3. Quels sont les degr√©s de libert√©s effectifs du terme non-lin√©aire ?


<!-- nous n'Avons pas encore parler du edf -->
---
# D√©fi 1 - Solution ![:cube]()

```{r,eval=false}
linear_model_s1 <- gam(Sources ~ SampleDepth,isit1)
gam_model_s1 <- gam(Sources ~ s(SampleDepth),data=isit1)

```

---
# D√©fi 1 - Solution ![:cube]()

```{r,echo=F}
ggplot(isit1,aes(x=SampleDepth, y=Sources)) +
         geom_point()+
         geom_line(colour = "red", size = 1.2,
                   aes(y = fitted(linear_model_s1))) +
         geom_line(colour = "blue", size = 1.2,
                   aes(y = fitted(gam_model_s1))) +
         theme_bw()
```
---
# D√©fi 1 - Solution ![:cube]()

```{r}
linear_model_s1 <- gam(Sources ~ SampleDepth,data=isit1)
nested_gam_model_s1 <- gam(Sources ~ s(SampleDepth) + SampleDepth,data=isit1)

AIC(linear_model_s1, nested_gam_model_s1)
```


---
# D√©fi 1 - Solution ![:cube]()

```{r}
nested_gam_model_s1
```


**R√©ponse** Oui la non-lin√©arit√© est justifi√©e. Les degr√©s de libert√©s effectifs (edf) sont >> 1 (on reviendra la dessus bient√¥t).

---
exclude:true
# D√©fi 1 ![:cube]()

Nous allons maintenant essayer cela avec d'autres donn√©es g√©n√©r√©es al√©atoirement.

```{r,eval=FALSE}
n <- 250
x_test <- runif(n, -5, 5)
y_test_fit <- 4 * dnorm(x_test)
y_test_obs <- rnorm(n, y_test_fit, 0.2)
```

1. Ajustez un mod√®le lin√©aire et un GAM √† la relation entre `x_test` et `y_test_obs`.
2. D√©terminez si l'hypoth√®se de lin√©arit√© est justifi√©e pour ces donn√©es.
3. Quels sont les degr√©s de libert√©s effectifs du terme non-lin√©aire ?


<!-- nous n'avons pas parl√© de degr√©s de libert√© avant... -->

---
exclude:true
# D√©fi 1 - Solution ![:cube]()

```{r,eval=FALSE}
linear_model_test <- gam(y_test_obs ~ x_test)
nested_gam_model_test <- gam(y_test_obs ~ s(x_test) + x_test)

AIC(linear_model_test, nested_gam_model_test, test="Chisq")
```

---
exclude:true
# D√©fi 1 - Solution ![:cube]()

```{r,eval=FALSE}
qplot(x_test, y_test_obs) +
  geom_line(aes(y = y_test_fit)) +
  theme_bw()
```

---
exclude:true
# D√©fi 1 - Solution ![:cube]()

```{r,eval=FALSE}
nested_gam_model_test
```

**R√©ponse** Oui la non-lin√©arit√© est justifi√©e. Les degr√©s de libert√©s effectifs (edf) sont >> 1 (on reviendra la dessus bient√¥t).

---
class: inverse, center, middle

## 3. Plusieurs termes non lin√©aires
---
# GAM √† plusieurs variables

Avec les GAMs, il est facile d'ajouter des termes non lin√©aires et lin√©aires dans un seul mod√®le, plusieurs termes non lin√©aires ou m√™me des interactions non lin√©aires.

Dans cette section, nous allons utiliser les donnÈes de `ISIT` de nouveau.

```{r,eval=FALSE}
isit
head(isit)
isit$Season <- as.factor(isit$Season)
```

Nous allons essayer de mod√©liser la r√©ponse `Sources` avec les prÈdicteurs `Season` and `SampleDepth` simultanÈment.

---
# GAM √† plusieurs variables

Commen√ßons par un mod√®le de base comprenant un terme non lin√©aire (`SampleDepth`) et un facteur qualitatif (`Season` avec 2 niveaux).

```{r}
basic_model <- gam(Sources ~ Season + s(SampleDepth), data = isit)
basic_summary <- summary(basic_model)
basic_summary$p.table

basic_summary$s.table
```

.comment[La sortie de `p.table` fournit le tableau de r√©sultats pour chaque terme param√©trique

Le tableau `s.table` nous donne les r√©sultats du terme non lin√©aire.
]

---
exclude:true
# GAM √† plusieurs variables

Avec les GAMs, il est facile d'ajouter des termes non lin√©aires et lin√©aires dans un seul mod√®le, plusieurs termes non lin√©aires ou m√™me des interactions non lin√©aires.

Dans cette section, nous allons utiliser un ensemble de donn√©es g√©n√©r√©es automatiquement par `mgcv::gamSim()`.

```{r,eval=FALSE}
# ?gamSim
gam_data <-  gamSim(eg = 5)
head(gam_data)
```

Nous allons essayer de mod√©liser la r√©ponse `y` avec les pr√©dicteurs `x0` √† `x3`.

---
exclude:true
# GAM √† plusieurs variables

Commen√ßons par un mod√®le de base comprenant un terme non lin√©aire (`x1`) et un facteur qualitatif (`x0` avec 4 niveaux).

```{r,eval=FALSE}
basic_model <- gam(y ~ x0 + s(x1), data = gam_data)
basic_summary <- summary(basic_model)
basic_summary$p.table

basic_summary$s.table
```
.comment[La sortie de `p.table` fournit le tableau de r√©sultats pour chaque terme param√©trique

Le tableau `s.table` nous donne les r√©sultats du terme non lin√©aire.
]

---
# Note sur les degr√©s de libert√© estim√©s

```{r}
basic_summary$s.table
```

Le param√®tre `edf` indiqu√© dans le tableau `s.table` correspond au degr√©s de libert√© estim√©s ‚Äì essentiellement, plus la valeur de l'edf est √©lev√©e, plus la non-lin√©arit√© est forte.

- Une valeur proche de 1 se rapproche d'un terme lin√©aire.

- Une valeur elev√©e (8‚Äì10 ou plus) signifie que la courbe est fortement non-lin√©aire.

> Dans notre mod√®le de base, l'edf du terme non-lin√©aire `s(x1)` est ~2, ce qui sugg√®re une courbe non-lin√©aire.

---
# Note sur les degr√©s de libert√© estim√©s

Les edf dans un GAM sont diff√©rents des degr√©s de libert√© dans une r√©gression lin√©aire.

Dans la r√©gression lin√©aire, les degr√©s de libert√©s du *mod√®le* sont √©quivalents au nombre de param√®tres libres non redondants, p, dans le mod√®le (et les degr√©s de libert√©s *r√©siduels* sont √©gaux √† $n-p$).

Nous reviendrons plus tard sur le concept d'edf.

---
# GAM √† plusieurs variables

```{r}
plot(basic_model,all.terms = T,page=1)
```
---
# GAM √† plusieurs variables

Nous pouvons ajouter un second terme, `RelativeDepth`, mais sp√©cifier une relation lin√©aire avec `Sources`

```{r}
two_smooth_model <- gam(Sources ~ Season + s(SampleDepth) + s(RelativeDepth), data = isit)
two_smooth_summary <- summary(two_smooth_model)
two_smooth_summary$p.table

two_smooth_summary$s.table
```

---
# GAM √† plusieurs variables


Nous pouvons aussi vÈrifier que la relation entre `Sources` et `RelativeDepth` est non-linÈaire.

```{r, fig.width=10}
plot(two_smooth_model, page = 1,all.terms = T)
```

---
# GAM √† plusieurs variables


Comme auparavant, nous pouvons utilisre un AIC pour tester si le lissage de la variable est nÈcessaire.

```{r}
AIC(basic_model, two_term_model, two_smooth_model)
```

.alert[Le meilleur mod√®le est le mod√®le avec deux fonctions non lin√©aires.]

---
exclude:true
# GAM √† plusieurs variables

Nous pouvons ajouter un second terme, `x2`, mais sp√©cifier une relation lin√©aire avec `y`

```{r,eval=FALSE}
two_term_model <- gam(y ~ x0 + s(x1) + x2, data = gam_data)
two_term_summary <- summary(two_term_model)
two_term_summary$p.table

two_term_summary$s.table
```

---
exclude:true
# GAM √† plusieurs variables

Nous pouvons ajouter un second terme, `x2`, mais sp√©cifier une relation lin√©aire avec `y`

```{r, fig.width=5.5, fig.height=5.5,eval=FALSE}
plot(two_term_model,all.terms = T)
```


---
exclude:true
# GAM √† plusieurs variables

Nous pouvons aussi explorer si la relation entre `y` et `x2` est non-lin√©aire

```{r,eval=FALSE}
two_smooth_model <- gam(y ~ x0 + s(x1) + s(x2), data = gam_data)
two_smooth_summary <- summary(two_smooth_model)
two_smooth_summary$p.table

two_smooth_summary$s.table
```

---
exclude:true
# GAM √† plusieurs variables

Nous pouvons aussi explorer si la relation entre `y` et `x2` est non-lin√©aire

```{r, fig.width=10,eval=FALSE}
plot(two_smooth_model, page = 1,all.terms = T)
```

---
exclude:true
# GAM √† plusieurs variables

Comme avant, nous pouvons faire une AIC pour tester si le terme non-lin√©aire est n√©cessaire

```{r,eval=FALSE}
AIC(basic_model, two_term_model, two_smooth_model)
```

.alert[Le meilleur mod√®le est le mod√®le avec deux fonctions non lin√©aires.]
---
# DÈfi 2 ![:cube]()

<br>

1. Cr√©ez deux nouveaux mod√®les avec la variable `Latitude` comme param√®tre lin√©aire et non lin√©aire.
2. Utilisez des graphiques, les tables des coefficients et la fonction `AIC()` afin de d√©terminer s'il est n√©cessaire d'inclure `Latitude` dans le mod√®le.

---
exclude:true
# D√©fi 2 ![:cube]()

<br>

1. Cr√©ez deux nouveaux mod√®les avec la variable `x3` comme param√®tre lin√©aire et non lin√©aire.
2. Utilisez des graphiques, les tables des coefficients et la fonction `AIC()` afin de d√©terminer s'il est n√©cessaire d'inclure `x3` dans le mod√®le.
---
# D√©fi 2 - Solution ![:cube]()
```{r}
three_term_model <- gam(Sources ~ Season + s(SampleDepth) + s(RelativeDepth) + Latitude, data = isit)
three_smooth_model <- gam(Sources ~ Season + s(SampleDepth) + s(RelativeDepth) + s(Latitude), data = isit)
three_smooth_summary <- summary(three_smooth_model)
three_smooth_summary
```
---
exclude:true
# D√©fi 2 - Solution ![:cube]()

<br>
```{r,eval=FALSE}
three_term_model <- gam(y ~ x0 + s(x1) + s(x2) + x3, data = gam_data)
three_smooth_model <- gam(y~x0 + s(x1) + s(x2) + s(x3), data = gam_data)
three_smooth_summary <- summary(three_smooth_model)
```

---
# D√©fi 2 - Solution ![:cube]()

```{r, eval = FALSE}
plot(three_smooth_model, page = 1, all.terms = T)
```

```{r, fig.width=8, fig.height=7, echo = FALSE}
par(mar=c(3.8,3.8,.2,.2))
plot(three_smooth_model, page = 1,all.terms = T)
```

---
# D√©fi 2 - Solution ![:cube]()

```{r}
three_smooth_summary$s.table

# edf = 1 donc le terme est lin√©aire.

AIC(two_smooth_model, three_term_model)

```


---
class: inverse, center, middle

## 4. Int√©ractions
---
# GAM avec des termes d'interaction

Il y a deux fa√ßons de mod√©liser une interaction entre deux variables :

- pour deux variables non-lin√©aire : `s(x1, x2)`
- pour une variable non-lin√©aire et une variable lin√©aire (quantitative ou qualitative) : utiliser l'argument `by`, `s(x1, by = x2)`
  - Quand `x2` est qualitative, vous avez un terme non lin√©aire qui varie entre les diff√©rents niveaux de `x2`
  - Quand `x2` est quantitative, l'effet lin√©aire de `x2` varie avec `x1`
  - Quand `x2` est qualitative, le facteur doit √™tre ajout√© comme effet principal dans le mod√®le

---
# GAM avec des termes d'interaction

Nous allons examiner l'effet de l'interaction en utilisant notre variable qualitative `Season` et examiner si la non-lin√©arit√© de `s(SampleDepth)` varie selon les diff√©rents niveaux de `Season`.

```{r}
factor_interact <- gam(Sources ~ Season + s(SampleDepth,by=Season) + s(RelativeDepth), data = isit)

summary(factor_interact)$s.table
```

---
exculde:true
# GAM avec des termes d'interaction

Nous allons examiner l'effet de l'interaction en utilisant notre variable qualitative `x0` et examiner si la non-lin√©arit√© de `s(x2)` varie selon les diff√©rents niveaux de `x0`.

```{r,eval=FALSE}
factor_interact <- gam(y ~ x0 + s(x1) + s(x2, by = x0), data = gam_data)

summary(factor_interact)$s.table
```

---
# GAM avec des termes d'interaction

```{r, fig.width=8}
plot(factor_interact, page = 1)
```

---
exclude:true
# GAM avec des termes d'interaction

Nous pouvons aussi visualiser notre mod√®le en 3D avec `vis.gam`, o√π `theta` est le degr√© de rotation de notre plan x-y

```{r,fig.width=5.5, fig.height=5.5}
vis.gam(factor_interact, view = c("SampleDepth","Season"), theta = 40, n.grid = 500, border = NA)
```

---
# GAM avec des termes d'interaction

Faisons une comparaison de mod√®le avec AIC pour d√©terminer si le terme d'interaction est n√©cessaire

```{r}
AIC(two_smooth_model, factor_interact)
```

√Ä partir des graphiques, on voit que les formes des termes non-lin√©aires sont comparables parmi les 4 niveaux de `x0`. L'AIC confirme cela aussi (p > 0.05).

---
# GAM avec des termes d'interaction

Finalement, nous regardons les interactions entre 2 termes non lin√©aires, `SampleDepth` et `RelativeDepth`.

```{r}
smooth_interact <- gam(Sources~Season + s(SampleDepth, RelativeDepth), data = isit)
summary(smooth_interact)$s.table
```

---
# GAM avec des termes d'interaction

```{r, fig.width=7, fig.height=7}
plot(smooth_interact, page = 1, scheme = 3)
```


---
exclude:true
# GAM avec des termes d'interaction

```{r, fig.width=8, fig.height=8,eval=FALSE}
vis.gam(smooth_interact, view = c("x1", "x2"), theta=40, n.grid = 500, border = NA)
# similaire √† plot(smooth_interact, page = 1, scheme = 1)
```

---
# GAM avec des termes d'interaction

```{r}
AIC(two_smooth_model, smooth_interact)
```

Le modËle avec l'int√©raction entre `s(SampleDepth)` et `s(RelativeDepth)` a une plus petite valeur d'AIC et le graphique en 2D illustre bien cette int√©raction non-lin√©aire, o√π `Sources` est faible pour de fortes valeurs de `SampleDepth` mais ÈlevÈ pour de moyennes ‡ hautes  valeurs de `RelativeDepth`.

---
class: inverse, center, middle

## 5. Changer la fonction de base

---
# √âtendre le mod√®le de base de GAM

Il est possible de modifier le mod√®le de base de GAM que nous avons vu avec :

1. des fonctions plus complexes en modifiant la fonction de base (par exemple, cyclique),
2. d'autres distributions : tout ce que vous pouvez faire avec un GLM (tel que sp√©cifier l'argument `family`) est possible avec les GAMs,
3. des mod√®les √† effets mixtes en utilisant la fonction `gamm` ou le paquet `gamm4`.

Nous allons maintenant passer au travers de ces 3 extensions.

---
# Other smooth functions

Pour mod√©liser une surface lisse ou non-lin√©aire, nous pouvons utiliser trois fonctions lisses diff√©rentes :

`s()` ![:faic](arrow-right) pour mod√©liser un terme lisse 1-dimensionnel, ou pour mod√©liser une int√©raction entre des variables mesur√©es sur la *m√™me √©chelle*

`te()` ![:faic](arrow-right)  pour mod√©liser une surface d'interaction 2- ou n-dimensionnel entre des variables qui *ne sont pas sur la m√™me √©chelle*. Comprend les effets principaux.

`ti()` ![:faic](arrow-right) pour mod√©liser une surface d'interaction 2- ou n-dimensionnel *qui ne comprend pas les effets principaux*.

---
# Param√®tres des fonctions lisses

Les fonctions lisses ont beaucoup de param√®tres qui pourraient changer leur comportement. Les param√®tres les plus souvent utilis√©s sont les suivants :

`k` ![:faic](arrow-right) nombre de ‚Äònoeuds‚Äô
  - d√©termine la limite sup√©rieure du nombre de fonctions de base utilis√©es pour construire la courbe.
  - contraint l'ondulation d'une fonction lisse.
  - le nombre de fonctions de base est repr√©sent√© par l'edf.
  - par d√©faut, la limite sup√©rieure de k pour `s()` est ~9, et de 5 pour chaque dimension de `te()` and `ti()`.
  - k devrait √™tre < au nombre de donn√©es uniques.

---
# Param√®tres des fonctions lisses

Les fonctions lisses ont beaucoup de param√®tres qui pourraient changer leur comportement. Les param√®tres les plus souvent utilis√©s sont les suivants :


`d` ![:faic](arrow-right) sp√©cifie quelles variables d'une int√©raction se trouvent sur la m√™me √©chelle lorsqu'on utilise `te()` and `ti()`.
  - Par exemple, `te(Temps, largeur, hauteur, d=c(1,2))`, indique que la `largeur` et la `hauteur` sont sur la m√™me √©chelle, mais que `temps` ne l'est pas.

`bs` ![:faic](arrow-right) sp√©cifie la fonction de base sous-jacente.
  - pour `s()` on utilise `tp` (*thin plate regression spline*) et pour `te()` et `ti()` on utilise la base `cr` (*cubic regression spline*).

<!--last 2 slides were a copy-paste from this websites: http://www.sfs.uni-tuebingen.de/~jvanrij/Tutorial/GAMM.html. However, as I'm not a specialist of GAM, I let them asis, but we should modify them or at least site the website-->

---
# Exemple avec des donn√©es cycliques

Les donn√©es cycliques sont un bon exemple o√π changer la base est utile : vous voulez que le pr√©dicteur corresponde √† la fin.

Nous allons utiliser une s√©rie temporelle de donn√©es climatiques, divis√©es en mesures mensuelles, afin de d√©terminer s'il y a une tendance de temp√©rature annuelle.

```{r, eval = FALSE}
data(nottem) # Nottingham temperature time series
n_years <- length(nottem)/12
nottem_month <- rep(1:12, times = n_years)
nottem_year <- rep(1920:(1920 + n_years - 1), each = 12)
qplot(nottem_month, nottem, colour = factor(nottem_year), geom = "line") +
  theme_bw()
```

---
# Exemple avec des donn√©es cycliques

```{r, echo = F, fig.height=8, fig.width=12}
data(nottem)
n_years <- length(nottem)/12
nottem_month <- rep(1:12, times = n_years)
nottem_year <- rep(1920:(1920 + n_years - 1), each = 12)
qplot(nottem_month, nottem, colour = factor(nottem_year), geom = "line") +
  theme_bw()
```

---
# Exemple avec des donn√©es cycliques

Nous pouvons mod√©liser le changement cyclique de temp√©rature √† travers les mois et la tendance non-lin√©aire √† travers les ann√©es, en utilisant une spline cubique, ou `cc` pour mod√©liser les effets de mois ainsi qu'un terme non-lin√©aire pour la variable ann√©e.

```{r, fig.height=4, fig.width=8}
year_gam <- gam(nottem ~ s(nottem_year) + s(nottem_month, bs = "cc"))
summary(year_gam)$s.table
```

---
# Exemple avec des donn√©es cycliques

```{r, fig.height=5, fig.width=8}
plot(year_gam, page = 1, scale = 0)
```
Il y a une hausse d'environ 1-1.5 degr√©s au cours de la s√©rie, mais au cours d'une ann√©e, il y a une variation d'environ 20 degr√©s. Les donn√©es r√©elles varient autour de ces valeurs pr√©dites et ceci repr√©sente donc la variance inexpliqu√©e.

---
class: inverse, center, middle

## 6. Autres distributions

---
# GAM avec d'autres distributions

Un bref aper√ßu de l'utilisation des GAMs lorsque la variable r√©ponse ne suit pas une distribution normale ou que les donn√©es sont des abondances ou proportions (par exemple, distribution Gamma, binomiale, Poisson, binomiale n√©gative).

Nous allons utiliser un exemple de donn√©es o√π une r√©partition binomiale sera n√©cessaire; la variable r√©ponse repr√©sente le nombre de succ√®s (l'√©v√©nement a eu lieu) en fonction des d√©faillances au cours d'une exp√©rience.

```{r}
gam_data3 <- read.csv("data/other_dist.csv")
str(gam_data3)
```

<!-- should change the name of the variables in the csv files, to make them meaningful-->

---
# GAM avec d'autres distributions

```{r, fig.height=4, fig.width=4}
plot(range(gam_data3$x1), c(0,1), type = "n",
     main = "Probabilit√©s de succ√®s dans le temps",
     ylab = "Probabilit√©", xlab = "x1 (temps)")
abline(h = 0.5)

avg <- aggregate(prop ~ x1, data=gam_data3, mean)
lines(avg$x1, avg$prop, col = "orange", lwd = 2)
```

---
# GAM avec d'autres distributions

Nous allons tester si cette tendance est lin√©aire ou non avec un GAM logistique (nous utilisons une famille de distributions binomiales parce que nous avons des donn√©es de proportion).

```{r, warning=F}
prop_model <- gam(prop ~ s(x1), data = gam_data3, weights = total, family = "binomial")
prop_summary <- summary(prop_model)
prop_summary$p.table
prop_summary$s.table
```

<!--Warning messages:
1: In eval(family$initialize) : non-integer #successes in a binomial glm!??-->
.comment[Que repr√©sente l'intercepte dans ce mod√®le?

Qu'est ce que le terme de lissage indique?]

---
# GAM avec d'autres distributions

```{r, echo = FALSE}
prop_summary$p.table
```

.comment[Que repr√©sente l'intercepte dans ce mod√®le?]

**Rappel** le mod√®le utilise le nombre de succ√®s vs √©checs pour calculer le *logit*, qui est la logarithme du rapport entre les succ√®s et √©checs :

.small[
- Si succ√®s = √©checs, le rapport = 1 et le logit est de 0 (log(1) = 0).
- Si succ√®s > √©checs, le rapport > 1 et le logit a une valeur positive (log(2) = 0.69).
- Si succ√®s < √©checs, le rapport < 1 et le logit a une valeur n√©gative (log(.5) = -0.69).
]

--

> Ici, l'estim√© est positif ce qui signifie, qu'en moyenne, il y a plus de succ√®s que d'√©checs.

---
# GAM avec d'autres distributions

```{r, echo = FALSE}
prop_summary$s.table
```

.comment[Qu'est ce que le terme de lissage indique?]

Cela repr√©sente comment le ratio de succ√®s vs √©checs change sur l'√©chelle de $x1$.

--

> Puisque l'edf > 1, la proportion des succ√®s augmente plus rapidement avec $x1$

```{r, fig.height=3.5, fig.width=4, echo = FALSE}
par(mar = c(4,4,0,0))
plot(prop_model)
```

---
# Visualiser la tendance au fil du temps

Il y a diff√©rente fa√ßon de repr√©senter cette relation graphiquement :

- **Contribution/effet partiel** correspond aux effets isol√©s d'une interaction ou pr√©diction particuli√®re. Si vous visualisez votre mod√®le GAM avec `plot()`, vous obtenez les effets partiels.
- **effets additionn√©s** correspond aux mesures r√©ponse pr√©dites pour une valeur ou niveau donn√© de pr√©dicteurs. Si vous visualisez votre GAM avec `itsadug::plot_smooth()`, vous obtenez les effets additionn√©s.


---
# Visualiser la tendance au fil du temps

Que nous disent ces graphes sur les succ√®s et √©checs?

```{r, echo = FALSE, fig.height = 4.5, fig.width = 9}
library(itsadug)
par(mfrow=c(1,2), mar = c(4,4,0,0))
plot(prop_model, select=1, scale=0, shade=TRUE)
abline(h=0)

out <- plot_smooth(prop_model, view="x1",main="", print.summary=F)
diff <- find_difference(out$fv$fit, out$fv$CI, xVals=out$fv$x1)
addInterval(0, lowVals = diff$start, highVals = diff$end, col='red', lwd=2)
abline(v=c(diff$start, diff$end), lty=3, col='red')
text(mean(c(diff$start, diff$end)), 2.1, "succ√®s > √©checs", col = 'red', font = 2)
```



.pull-left[
**Contribution / effets partiels**

La valeur logit augmente, donc les succ√®s augmentent et les √©checs diminuent.]

.pull-right[
**Valeurs ajust√©es, effets additionn√©s, intercepte inclu**

Quantit√©s √©gales de succ√®s et d'√©checs jusqu'√† $x1 = 400$.
]

<!-- this code should be shown but it is not well explained...-->
---
# Visualiser la tendance au fil du temps

Enfin, pour nous aider √† interpr√©ter les r√©sultats, nous pouvons re-transformer l'effet sur une √©chelle de proportions avec la fonction `itsadug::plot_smooth()` :

```{r, echo = -1, fig.height=3.5, fig.width==4}
par(mar=c(3.8,4,0,0))
plot_smooth(prop_model, view = "x1", main = "",
            transform = plogis, ylim = c(0,1), print.summary = F)
abline(h = 0.5, v = diff$start, col = 'red', lty = 2)
```

Comme pr√©c√©demment, la proportion de succ√®s augmente au-dessus de 0.5 √† $x1 = 400$.

<!-- again, lack of explanation here...-->


---
class: inverse, center, middle

# 7. Intro rapide aux GAMMs

---
# La non-ind√©pendance des donn√©es

Lorsque les observations ne sont pas ind√©pendantes, les GAMs peuvent √™tre utilis√©s soit pour incorporer :

- une structure de corr√©lation pour mod√©liser les r√©sidus autocorr√©l√©s (autor√©gressif (AR), moyenne mobile (MA), ou une combinaison des deux (ARMA)) ,
- des effets al√©atoires qui mod√©lisent l'ind√©pendance entre les observations d'un m√™me site.

---
# Mod√®le avec erreurs autocorr√©l√©es

Pour commencer, nous allons jeter un coup d‚Äô≈ìil au premier cas; un mod√®le avec autocorr√©lation temporelle dans les r√©sidus. R√©-examinons le mod√®le de la temp√©rature de Nottingham et v√©rifions si les r√©sidus sont corr√©l√©s en faisant appel √† la fonction (partielle) d'autocorr√©lation.

```{r, eval = F, fig.width=9, fig.height=4.5}
par(mfrow = c(1,2))
acf(resid(year_gam), lag.max = 36, main = "ACF")
pacf(resid(year_gam), lag.max = 36, main = "pACF")
```

---
# Mod√®le avec erreurs autocorr√©l√©es

```{r, echo = F, fig.width=8.5, fig.height=4}
par(mfrow = c(1,2))
acf(resid(year_gam), lag.max = 36, main = "ACF")
pacf(resid(year_gam), lag.max = 36, main = "pACF")
```

.comment[ACF (et pACF) donne la corr√©lation crois√©e (et la corr√©lation partielle) d'une s√©rie temporelle avec elle-m√™me √† diff√©rent d√©calage de temps, et sont utilis√©s pour identifier combien d'intervalle de temps sont n√©cessaires pour que les observations commencent √† √™tre ind√©pendantes.]

 Les graphiques des fonctions d'autocorr√©lation sugg√®rent qu'un mod√®le AR de faible ordre est n√©cessaire (avec un ou deux intervalles de temps d√©cal√©s).

---
# Mod√®le avec erreurs autocorr√©l√©es

Nous pouvons tester l'autocorr√©lation en ajoutant des structures AR au mod√®le : AR(1) (corr√©lation avec un intervalle de temps d√©cal√©) ou un AR(2) (corr√©lation √† 2 intervalles de temps d√©cal√©s)

```{r}

year_gam <- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = "cc"))
year_gam_AR1 <- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = "cc"),
                     correlation = corARMA(form = ~ 1|nottem_year, p = 1),
                   data = data.frame(nottem, nottem_year, nottem_month))
year_gam_AR2 <- gamm(nottem ~ s(nottem_year) + s(nottem_month, bs = "cc"),
                     correlation = corARMA(form = ~ 1|nottem_year, p = 2),
                   data = data.frame(nottem, nottem_year, nottem_month))
AIC(year_gam$lme, year_gam_AR1$lme, year_gam_AR2$lme)
```

.comment[Le mod√®le avec la structure AR(1) pr√©voit une augmentation significative comparativement au premier mod√®le (LRT = 10,69, p = 0,0011), mais il y a tr√®s peu d'int√©r√™t √† consid√©rer le mod√®le AR(2) (LRT = 1,62, b = 0,203).]

---
# Mod√©lisation avec effets mixtes

Comme nous l'avons vu dans la section pr√©c√©dente, `bs` sp√©cifie la fonction de base sous-jacente. Pour les facteurs al√©atoires (origine et pente lin√©aire), nous utilisons `bs = "re"` et pour les pentes al√©atoires non lin√©aires, nous utilisons `bs = "fs"`.

---
# Mod√©lisation avec effets mixtes

**3 types d'effets al√©atoires diff√©rents** sont possibles lors de l'utilisation des GAMMs (o√π `fac` ![:faic](arrow-right) variable qualitative utilis√©e pour l'effet al√©atoire; `x0` ![:faic](arrow-right) effet quantitatif fixe) :

- **interceptes al√©atoires** ajustent la hauteur des termes du mod√®le avec une valeur constante de pente : `s(fac, bs="re")`
- **pentes al√©atoires** ajustent la pente d'une variable explicative num√©rique : `s(fac, x0, bs="re")`
- **surfaces lisses al√©atoires** ajustent la tendance d'une pr√©diction num√©rique de fa√ßon non lin√©aire: `s(x0, fac, bs="fs", m=1)`, o√π l'argument $m = 1$ met une plus grande p√©nalit√© au lissage qui s'√©loigne de 0, ce qui entra√Æne un retrait vers la moyenne.

---
# GAMM avec un intercepte al√©atoire

Tel que vu pr√©c√©demment, nous allons utiliser `gamSim()` pour g√©n√©rer un ensemble de donn√©es, cette fois-ci avec une composante d'effet al√©atoire. Ensuite, nous construirons un mod√®le avec un intercepte al√©atoire en utilisant `fac` comme facteur al√©atoire.

```{r}
gam_data2 <- gamSim(eg = 6)
str(gam_data2)
```


---
# GAMM avec un intercepte al√©atoire

```{r, fig.height=4.5, fig.width=5.5, echo = -1}
par(mar=c(4,4,1,1))
gamm_intercept <- gam(y ~ s(x0) + s(fac, bs = "re"), data = gam_data2)
summary(gamm_intercept)$s.table
plot(gamm_intercept, select = 2)
```

---
# GAMM avec un intercepte al√©atoire

Nous allons premi√®rement tracer l'effet combin√© de `x0` (sans les niveaux de l'effet al√©atoire) et ensuite une courbe pour les 4 niveaux de `fac` :

```{r, eval = FALSE}
par(mfrow = c(1,2), cex = 1.1)

plot_smooth(gamm_intercept, view = "x0", rm.ranef = T,
            main = "intercept + s(x1)")

plot_smooth(gamm_intercept, view = "x0", cond = list(fac="1"),
            main = "... + s(fac)", col = 'orange', ylim = c(8,21))

plot_smooth(gamm_intercept, view = "x0", cond = list(fac = "2"), add = T, col = 'red')

plot_smooth(gamm_intercept, view="x0", cond = list(fac = "3"), add = T, col = 'purple')

plot_smooth(gamm_intercept, view="x0", cond = list(fac = "4"), add = T, col = 'turquoise')
```

---
# GAMM avec un intercepte al√©atoire

<br>

```{r, echo = F, fig.width=12, fig.height=6}
par(mfrow = c(1,2), cex = 1.1, mar=c(4,4,1,1))
plot_smooth(gamm_intercept, view = "x0", rm.ranef = T,
            main = "intercept + s(x1)", print.summary=F)
plot_smooth(gamm_intercept, view = "x0", cond = list(fac="1"),
            main = "... + s(fac)", col = 'orange', ylim = c(8,21), print.summary=F)
plot_smooth(gamm_intercept, view = "x0", cond = list(fac = "2"), add = T, col = 'red', print.summary=F)
plot_smooth(gamm_intercept, view="x0", cond = list(fac = "3"), add = T, col = 'purple', print.summary=F)
plot_smooth(gamm_intercept, view="x0", cond = list(fac = "4"), add = T, col = 'turquoise', print.summary=F)
```

.pull-right[
&nbsp; <font color="orange">fac1</font> &nbsp; <font color="red">fac2</font> &nbsp; <font color="purple">fac3</font> &nbsp; <font color="turquoise">fac4</font>
]


---
# GAMM avec une pente al√©atoire

```{r}
gamm_slope <- gam(y ~ s(x0) + s(x0, fac, bs = "re"), data = gam_data2)

summary(gamm_slope)$s.table
```


---
# GAMM avec une pente al√©atoire

```{r, eval = FALSE}
par(mfrow = c(1,2), cex = 1.1)

plot_smooth(gamm_slope, view = "x0", rm.ranef = T, main = "intercept + s(x0)")

plot_smooth(gamm_slope, view = "x0", cond = list(fac = "1"),
            main = "... + s(fac)", col = 'orange', ylim = c(7,22))

plot_smooth(gamm_slope, view = "x0", cond = list(fac = "2"), add = T, col = 'red')

plot_smooth(gamm_slope, view = "x0", cond = list(fac = "3"), add = T, col = 'purple')

plot_smooth(gamm_slope, view = "x0", cond = list(fac = "4"), add = T, col = 'turquoise')
```

---
# GAMM avec une pente al√©atoire

<br>

```{r, echo = F, fig.width=12, fig.height=6}
par(mfrow = c(1,2), cex = 1.1, mar=c(4,4,1,1))
plot_smooth(gamm_slope, view = "x0", rm.ranef = T, main = "intercept + s(x0)",
            print.summary=F)
plot_smooth(gamm_slope, view = "x0", cond = list(fac = "1"),
            main = "... + s(fac)", col = 'orange', ylim = c(7,22), print.summary=F)
plot_smooth(gamm_slope, view = "x0", cond = list(fac = "2"), add = T, col = 'red',
            print.summary=F)
plot_smooth(gamm_slope, view = "x0", cond = list(fac = "3"), add = T, col = 'purple',
            print.summary=F)
plot_smooth(gamm_slope, view = "x0", cond = list(fac = "4"), add = T, col = 'turquoise',
            print.summary=F)
```

---
# GAMM avec un intercepte et une pente al√©atoire

```{r}
gamm_int_slope <- gam(y ~ s(x0) + s(fac, bs = "re") + s(fac, x0, bs = "re"),
                      data = gam_data2)

summary(gamm_int_slope)$s.table
```

---
# GAMM avec un intercepte et une pente al√©atoire

```{r, eval = FALSE}
par(mfrow = c(1,2), cex = 1.1)

plot_smooth(gamm_int_slope, view = "x0", rm.ranef = T, main = "intercept + s(x0)")

plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "1"),
            main="... + s(fac) + s(fac, x0)", col = 'orange', ylim = c(7,22))

plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "2"), add = T, col='red')

plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "3"), add = T, col = 'purple')

plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "4"), add = T, col = 'turquoise')
```

---
# GAMM avec un intercepte et une pente al√©atoire

<br>

```{r, echo = F, fig.width=12, fig.height=6}
par(mfrow = c(1,2), cex = 1.1, mar=c(4,4,1,1))
plot_smooth(gamm_int_slope, view = "x0", rm.ranef = T, main = "intercept + s(x0)", print.summary=F)
plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "1"), print.summary=F,
            main="... + s(fac) + s(fac, x0)", col = 'orange', ylim = c(7,22))
plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "2"), add = T,
            col='red',print.summary=F)
plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "3"), add = T,
            col = 'purple', print.summary=F)
plot_smooth(gamm_int_slope, view = "x0", cond = list(fac = "4"), add = T,
            col = 'turquoise', print.summary=F)
```

---
# GAMM avec un intercepte et une pente al√©atoire

Notez que la pente al√©atoire est statique dans ce cas :

```{r, fig.width=5, fig.height=5}
plot(gamm_int_slope, select = 3)
```

---
# GAMM avec une surface lisse al√©atoire

```{r}
gamm_smooth <- gam(y ~ s(x0, fac, bs = "fs", m = 1), data = gam_data2)

summary(gamm_smooth)$s.table
```

---
# GAMM avec une surface lisse al√©atoire

Ici, si les pentes al√©atoires variaient selon `x0`, nous aurons des courbes variables pour chaque niveau :

```{r, echo = -1, fig.height=5, fig.width=5}
par(mar=c(4,4,.5,.5), lwd = 2)
plot(gamm_smooth, select = 1)
```

---
# GAMM avec une surface lisse al√©atoire

```{r, eval = FALSE}
par(mfrow = c(1,2), cex = 1.1)

plot_smooth(gamm_smooth, view = "x0", rm.ranef = T, main = "intercept + s(x0)")

plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "1"),
            main="... + s(x0, fac)", col = 'orange', ylim = c(7,22))

plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "2"), add = T, col='red')

plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "3"), add = T, col = 'purple')

plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "4"), add = T, col = 'turquoise')
```

---
# GAMM avec une surface lisse al√©atoire

<br>

```{r, echo = F, fig.width=12, fig.height=6}
par(mfrow = c(1,2), cex = 1.1, mar=c(4,4,1,1))
plot_smooth(gamm_smooth, view = "x0", rm.ranef = T, main = "intercept + s(x0)", print.summary=F)
plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "1"), print.summary=F,
            main="... + s(x0, fac)", col = 'orange', ylim = c(7,22))
plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "2"), add = T,
            col='red',print.summary=F)
plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "3"), add = T,
            col = 'purple', print.summary=F)
plot_smooth(gamm_smooth, view = "x0", cond = list(fac = "4"), add = T,
            col = 'turquoise', print.summary=F)
```

.comment[Ici, si la pente al√©atoire varie selon `x0`, nous aurons des courbes variables pour chaque niveau.]

---
# GAMM

Tous ces mod√®les mixtes peuvent √™tre compar√©s en utilisant la fonction `AIC()` pour trouver le meilleur mod√®le.

```{r}
AIC(gamm_intercept, gamm_slope, gamm_int_slope, gamm_smooth, test = "Chisq")
```

---
class: inverse, center, middle

# 8. Les GAMs en coulisse


---
# Un regard plus approfondi sur les GAMs

Nous allons maintenant prendre quelques minutes pour regarder comment fonctionnent les GAMs. Commen√ßons en consid√©rant d'abord un mod√®le qui contient une fonction lisse d'une covariable, $x_i$ :

$$y_i = f(x_i) + Œµ_i$$

Pour estimer la fonction $f$, nous avons besoin de repr√©senter l'√©quation ci-dessus de mani√®re √† ce qu'elle devienne un mod√®le lin√©aire. Cela peut √™tre fait en choisissant une base, $b_i(x)$, d√©finissant l'espace des fonctions dont $f$ est un √©l√©ment :

$$f(x) = \sum_{i=1}^q b_i(x) \times Œ≤_i$$

---
# Exemple : une base polynomiale

Supposons que $f$ est consid√©r√©e comme un polyn√¥me d'ordre 4, de sorte que l'espace des polyn√¥mes d'ordre 4 et moins contient $f$. Une base de cet espace serait alors :

$$b_1(x)=1,   b_2(x)=x,   b_3(x)=x^2,   b_4(x)=x^3,   b_5(x)=x^4$$

et $f(x)$ devient :

$$f(x) = Œ≤_1 + x_iŒ≤_2 +  x^2_iŒ≤_3 + x^3_iŒ≤_4(x) + x^4_iŒ≤_5$$

et le mod√®le complet devient :

$$y_i = Œ≤_1 + x_iŒ≤_2 +  x^2_iŒ≤_3 + x^3_iŒ≤_4(x) + x^4_iŒ≤_5 + Œµ_i$$

---
# Exemple : une base polynomiale

Chaque fonction de base est multipli√©e par un param√®tre √† valeur r√©elle, $Œ≤_i$, et est ensuite additionn√©e pour donner la <font color="orange">courbe finale $f(x)$</font>.

.center[
![:scale 85%](images/polynomial_basis_example.png)
]

En faisant varier le coefficient $Œ≤_i$, on peut faire varier la forme de $f(x)$ pour produire une fonction polynomiale d'ordre 4 ou moins.

---
# Exemple : une base de spline cubique

Un spline cubique est une courbe construite √† partir de sections d'un polyn√¥me cubique reli√©es entre elles de sorte qu'elles sont continues en valeur. Chaque section du spline a des coefficients diff√©rents.

.center[
![](images/cubic_spline.png)
]

---
# Exemple : une base de spline cubique

Voici une repr√©sentation d'une fonction lisse utilisant une base de r√©gression spline cubique de rang 5 avec des n≈ìuds situ√©s √† incr√©ments de 0.2:

.center[
![:scale 40%](images/cubic_spline5.jpg)
]

Dans cet exemple, les n≈ìuds sont espac√©s uniform√©ment √† travers la gamme des valeurs observ√©es de x. Le choix du degr√© de finesse du mod√®le est pr√©-d√©termin√© par le nombre de n≈ìuds, qui √©tait arbitraire.

.comment[Y a-t-il une meilleure fa√ßon de s√©lectionner les emplacements des n≈ìuds?]

---
# Contr√¥ler le degr√© de lissage avec des splines de r√©gression p√©nalis√©s

Au lieu de contr√¥ler le lissage (non lin√©arit√©) en modifiant le nombre de n≈ìuds, nous gardons celui-ci fix√© √† une taille un peu plus grande que raisonnablement n√©cessaire et on contr√¥le le lissage du mod√®le en ajoutant une p√©nalit√© sur le niveau de courbure. Donc, plut√¥t que d'ajuster le mod√®le en minimisant (comme avec la m√©thode des moindres carr√©s) :

$$||y - XB||^{2}$$

Il peut √™tre mod√©lis√© en minimisant :

$$||y - XB||^{2} + \lambda \int_0^1[f^{''}(x)]^2dx$$

Quand $\lambda$ tend vers $‚àû$, le mod√®le devient lin√©aire.

---
# Contr√¥ler le degr√© de lissage avec des splines de r√©gression p√©nalis√©s

Si $Œª$ est trop √©lev√©, les donn√©es seront trop liss√©es et si elle est trop faible, les donn√©es ne seront pas assez liss√©es. Id√©alement, il serait bon de choisir une valeur $Œª$ de sorte que le $\hat{f}$ pr√©dit est aussi proche que possible du $f$ observ√©. Un crit√®re appropri√© pourrait √™tre de choisir $Œª$ pour minimiser :

$$M = 1/n \times \sum_{i=1}^n (\hat{f_i} - f_i)^2$$

√âtant donn√© que $f$ est inconnue, $M$ est estim√© en utilisant une technique de validation crois√©e g√©n√©ralis√©e qui laisse de c√¥t√©, √† chaque tour, une donn√©e et estime la capacit√© moyenne des mod√®les, construits sur les donn√©es restantes, de pr√©dire la donn√©e qui a √©t√© mise de c√¥t√©.

---
# Principe de validation crois√©e

.center[
![:scale 60%](images/smooth_sel.png)
]

1. ajustement faible par rapport aux donn√©es et ne fait pas mieux avec le point manquant.

--

2. tr√®s bon ajustement de la courbe du signal sous-jacent, le lissage passe √† travers le bruit et la donn√©e manquante est plut√¥t bien pr√©dite.

--

3. la courbe ajuste le bruit aussi bien que le signal, la variabilit√© suppl√©mentaire am√®ne √† pr√©dire la donn√©e manquante plut√¥t mal.

---
# Principe de validation crois√©e

.center[
![](images/gcv.png)
]


---
# Note suppl√©mentaire sur les degr√©s de libert√© effectifs (edf)

Combien de degr√©s de libert√© a un GAM ?

Au lieu de fournir la sortie de la validation crois√©e en termes de $\lambda$ (complexit√© de l'ajustement), la fonction GAM du paquet `mgvc` utilise un terme appel√© les degr√©s de libert√© effectifs (edf).


---
# Note suppl√©mentaire sur les degr√©s de libert√© effectifs (edf)

Parce que le nombre de param√®tres libres des splines de lissage (tel que les GAMs) est souvent difficile √† d√©finir, les edf sont li√©s √† $\lambda$, o√π l'effet de la p√©nalit√© est de r√©duire les degr√©s de libert√©s.

Par exemple, si le nombre de noeuds est arbitrairement r√©gl√© √† k = 10, k-1 d√©finit la limite sup√©rieure des degr√©s de libert√©s associ√©s √† un terme de lissage. Ce nombre diminue alors que la p√©nalit√© $\lambda$ augmente jusqu'√† ce que le meilleur mod√®le soit trouv√© par validation crois√©e.

---
# Ressources

Il existe beaucoup d'information sur les GAMs.

Simon Wood, l'auteur de la librairie `mgcv`, a un [site](http://people.bath.ac.uk/sw283/mgcv/) tr√®s utile avec des conf√©rences et des notes introductives sur la fa√ßon d'utiliser les GAMs.

Il a aussi √©crit un livre, *Generalized Additive Models: An Introduction with R*, que nous avons utilis√© comme r√©f√©rence pour cet atelier.

.center[[![:scale 28%](https://images.tandf.co.uk/common/jackets/amazon/978149872/9781498728331.jpg)](https://www.crcpress.com/Generalized-Additive-Models-An-Introduction-with-R-Second-Edition/Wood/p/book/9781498728331)]


---
# Ressources

Le mat√©riel de cet atelier a √©galement √©t√© obtenu √† partir des blogs et des tutoriels suivants :

- [From the bottom of the heap](http://www.fromthebottomoftheheap.net/blog/)

- [Overview GAMM analysis of time series data](http://www.sfs.uni-tuebingen.de/~jvanrij/Tutorial/GAMM.html)

- [Advanced Analysis of Time series data](http://www.sfs.uni-tuebingen.de/~jvanrij/LSA2015/AnswersLab2.html)

- Noam Ross a cr√©e un tutorial [GAMs in R](https://noamross.github.io/gams-in-r-course/) (voir aussi [ce preprint](https://peerj.com/preprints/27320/))

Enfin, les pages d'aide, disponibles via `?gam` dans R sont une excellente ressource.

---
class: inverse, center, bottom

# Merci pour votre participation √† cet atelier!

<hr>
<br>

![:scale 50%](images/qcbs_logo.png)
